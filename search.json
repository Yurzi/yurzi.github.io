[{"title":"dot语言学习笔记","url":"/posts/d5d87576/","content":"\n在学习生活中经常遇到需要绘制各种流程图，框图，UML图的情况，一种比较方便的方法就是使用**Graphviz**来进行绘制，而Graphviz使用Dot语言进行解析生成，故学习dot，并作此笔记\n\n<!--more-->\n\n## dot语法总结\n\n### dot的抽象语法\n\n|   对象    |                       格式与内容                       |\n| :-------: | :----------------------------------------------------: |\n|   graph   | [ strict ] (graph \\| digraph) [ ID ] '{' stmt_list '}' |\n| stmt_list |                  [stmt[';']stmt_list]                  |\n|   stmt    |                       node_stmt                        |\n| \\ | edge_stmt|\n| \\ | attr_stmt |\n| \\ | *ID*'='*ID* |\n| \\ | subgraph |\n| attr_stmt | (graph \\| node \\| edge ) attr_list |\n| attr_list | '[' [ a_list ] ']' [ attr_list ] |\n| edge_stmt\t|\t(node_id \\| subgraph) edgeRHS [ attr_list ] |\n| edgeRHS\t|\tedgeop (node_id \\| subgraph) [ edgeRHS ] |\n| node_stmt\t|\tnode_id [ attr_list ] |\n| node_id\t|\tID [ port ] |\n| port\t|\t':' ID [ ':' compass_pt ] |\n| \\ |\t':' compass_pt |\n| subgraph\t|\t[ subgraph [ ID ] ] '{' stmt_list '}' |\n| compass_pt\t|\t(n \\| ne \\| e \\| se \\| s \\| sw \\| w \\| nw \\| c \\| _) |\n\n### 关键字\n\n其中在有向图中使用`->`在无向图中使用`--`来表示边\n\n- node：节点属性\n- edge：连线属性\n- graph：图属性，或声明一个无向图时使用\n- digraph：有向图\n- subgraph：声明子视图，名字要以`cluster`开头。\n- strict：严格模式，用于防止相同的两个节点间使用重复的连线。\n\n```dot\ngraph G1 {\n    a -- b;\n    a -- d;\n    b -- c;\n    d -- c;\n}\n```\n\n```dot\ndigraph G1 {\n    edge [dir=none];\n    a -> b;\n    a -> d;\n    b -> c;\n    d -> c;\n}\n```\n\n### 元素声明和定义及属性\n\n#### 图(graph)\n\n##### 声明和定义\n\n使用(graph| digraph) graphName {}来声明和定义一个图。\n使用subgraph cluster_subGrapgName {}来在图中声明子图\n\n```\ndigraph example1 {\n  label = \"this is a graph\";\n  a;b;\n\n  subgraph cluster_subgraphName1 {\n    label = \"this is a  subgraph\";\n    bgcolor = blue;\n    c;d;\n  }\n}\n```\n\n##### 属性\n\n1. bgcolor：设置图的背景颜色，可以使用\brgb值，也可以用#rrggbb编码形式\n2. label：设置图的描述。label会继承到子图，如果不想子图重复label需手动设置\n3. rankdir：设置图的\b方向，包括：TB（\btop to bottom）、BT（bottom to top）、LR(left to 4. Right）、RL（right to left）\n5. rotate：设置图的旋转。如rotata = 90代表旋转90度，默认逆时针\n6. ratio：设置图的长宽比，可以是一个浮点数，也可以是：fill、compress、auto\n7. compounrd: 设置图内子图之间的边的连接，为布尔值\n\n** 在子图间建立边 **\n需要设置图的属性`compound=true`\n\n#### 节点(node)\n\n##### 声明与定义\n\n声明一个节点只需要输入节点的名字，抽象语法如下\n\n`nodeName [attr_list]`\n\n若节点的名字特殊可以使用双引号将其括起来，如\"x,y\"\n\n##### 属性\n\n可以使用`node`关键字设定全局节点属性\n\n1. shape：设置结点形状。包括：Mrecord（圆角矩形）、record（矩形）、circle（圆形）、box（矩形，和record略有区别，下面会讲到）、egg（蛋形）、doublecircle（双圆形）、plaintext（纯文本）、 ellipse（椭圆，默认）。更多详见[官方文档](https://graphviz.org/doc/info/shapes.html)\n2. label：设置结点的显示内容，内容用双引号包含，可以使用转义字符。当结点内容!=结点名时使用\n3. style：设置结点的样式。包括：filled(填充)、dotted（点状边框）、solid（普通边框）、dashed（虚线边框）、bold（边框加粗）、invis（隐形）。\n4. color：设置边框颜色。可以使用单词形式或者#rrggbb形式。\n5. fillcolor：设置填充颜色，仅style = filled时有效。\n6. width：设置结点宽度。\n7. height：设置结点高度。\n8. perpheries：设置结点边框个数。\n9. fontcolor：设置结点内容颜色。可以使用单词形式或者#rrggbb形式\n\n**Label**\n\n在label上record和box有所区别。原因就是：设置为record和Mrecord的结点的label属性可以很方便地生成单列的表格和UML图等。（类似于XAML里面的stack）\n\n用一对双引号+一对花括号包含起来的就是表格内容，不同的格子之间用符号 | 隔开，尖括号里的内容表示一个锚点\n\n例如：\n\n```\nexample [shape = record, label = \"{<head>cell1 | cell2 | cell3}\"];\n```\n\n### 边\n\n##### 声明和定义\n\n边的声明比较简单，只需用`->`(digraph)或者`--`(graph)将2个节点置于两侧即可，对于未声明的节点会自动声明。抽象化声明：\n`nodeName1 ->|-- nodeName2 [attr_list]`\n如：`a->b `\n\n##### 边的属性\n\n1.style：设置边的形状。包括：solid（实线）、dashed（虚线）、dotted（点线）、bold（加粗）、invis（隐形）。\n2.label：设置边标签。内容用双引号包含，可以使用转义字符。\n3.color：设置边颜色。可以使用单词形式或者#rrggbb形式。\n4.arrowhead：设置结点箭头样式。包括：none、empty、odiamond等详见[arrowhead样式表](https://graphviz.org/docs/attr-types/arrowType/)。\n5.ltail或者lhead:：当compound设置为true时，边被裁剪到子图的边界处\n6.headlabel/taillabel：边上靠近头部/尾部的标签\n\n### 注释与表格锚点\n\n使用`//`或者`/**/`来添加注释\n\n对于表格锚点，在表格中尖括号里的为表格锚点名称示例：\n\n```\ndigraph example2 {\n  node [shape = record];\n  table1 [label = \"{<head>cell1 | cell2 | cell3}\"];\n  table2 [label = \"{<head>cell1 | cell2}\"];\n\n  table1: head -> table2: head\n}\n```\n\n## dot应用\n\n### 支持中文\n\nGraphviz默认是不支持中文的，输入的中文在生成的图中显示为一个空方块。如果想要让其支持中文，可以尝试以下方法：\n\n- 在命令行制定-Nfontname = xxx.ttf，在gv文件中输入utf-8编码的汉字\n- 给graph、node、edge设置fontname = xxx.ttf然后设置label\n\n### 支持html\n\n**labal**属性支持html语言。\n\n### 绘制内容丰富的节点\n\n主要使用label标签的特性\n\n```\ndigraph structs {acyclic\n    node [shape=record];\n       struct1 [shape=record, label=\"<f0> left|<f1> mid\\ndle|<f2> right\"];\n       struct2 [shape=record, label=\"<f0> one|<f1> two\"];\n       struct3 [shape=record, label=\"hello\\nworld |{ b |{c|<here> d|e}| f}| g | h\"];\n       struct1 -> struct2;\n       struct1 -> struct3;\n}\n```\n\n### Graphviz的使用\n\n命令行的抽象语法\n`dot -[Tps|Tsvg|Tfig|Tpng|Tgif] -Nfontname = xxx.ttf -O outName`\n\n可能的内容如下：\n|选项| 用途 |\n|:-----:|:-----------:|\n| -Tps\t|输出PostScript|\n| -Tsvg|\t输出SVG|\n| -Tfig\t|输出XFIG|\n| -Tpng|\t输出PNG|\n| -Tgif\t|输出GIF|\n| -G键=值\t|设置默认图属性|\n| -N键=值\t|设置默认结点属性|\n| -E键=值\t|设置默认边属性|\n| -O | 自动生成输出文件名|\n| -sf尺度 |\t缩放输入默认72|\n| -y\t| 反转输入中的y坐标|\n\n## 参考文献\n\n1. Graphviz官方文档：https://graphviz.org/documentation/\n2. Code@浮生记. dot语法总结：https://onlookerliu.github.io/2017/12/28/dot%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/#2-%E5%9B%BE%E7%9A%84%E5%A3%B0%E6%98%8E\n3. li-peng. dot语法总结. cnblog：https://www.cnblogs.com/li-peng/p/14565148.html\n4. 码农家园的一篇文章：https://www.codenong.com/cs105791723/\n5. 小胖西瓜.Graphviz 画图的一些总结. cnblog：https://www.cnblogs.com/shuqin/p/11897207.html\n\n","tags":["笔记","dot"],"categories":["笔记","dot"]},{"title":"4-第一个程序","url":"/posts/93121487/","content":"## 一个源程序从写出到执行的过程\n\n**第一步**：编写汇编程序\n\n**第二步**：对源程序进行编译连接\n\n**可执行文件包含2个部分**\n\n1. 程序和数据\n2. 相关的描述信息\n\n**第三步**：执行可执行文件中的程序\n\n<!--more-->\n\n## 源程序\n\n例程：\n\n```assembly\nassume cs:codesg\n\ncodesg segment\n\n\tmov ax,0123H\n\tmov bx,0456H\n\tadd ax,bx\n\tadd ax,ax\n\t\n\tmov ax,4c00H\n\tint 21H\n\t\ncodesg ends\n\nend\n```\n\n\n\n在汇编语音的源程序中，包含2种指令，一种是汇编指令，一种是伪指令。汇编指令是对应的机器码的指令，可以被编译为机器指令。\n\n而伪指令没有对应的机器指令，是由编译器所执行的。来进行相关的编译工作\n\n### 伪指令\n\n#### segment与ends\n\n例程中的 segment 和 ends是一对成对使用的伪指令，是必须要用到的一对伪指令。\n\nsegment和ends的功能是定义一个段，segment说明一个段的开始。一个段必须有一个名称来标识\n\n```assembly\n段名 segment\n\n段名 ends\n```\n\n#### end\n\nend 是一个汇编程序的结束标记，汇编器在编译汇编程序的过程中，如果碰到了end就结束了对源程序的编译，否则 编译器在编译源程序时，无法知道程序在何处结束\n\n#### assume\n\n这条伪指令的含义是”假设“ 。它假设某一段寄存器和程序中的某一个用 segment……ends定义的段相关联。\n\n如在例程中，使用`assume cs:codesg`将cpu的段寄存器cs和codesg联系起来\n\n### 标号\n\n汇编源程序中，如例程中的codesg 则为标号，标号指代了一个地址。\n\n### 程序返回\n\n在例程中的\n\n```assembly\nmov ax,4c00H\nint 21H\n```\n\n可以实现程序返回到之前的程序执行\n\n","tags":["笔记","汇编","assembly x86_64"],"categories":["笔记","assembly x86_64","4-第一个程序"]},{"title":"3-寄存器(内存访问)","url":"/posts/2071e8f1/","content":"## 内存中字的存储\n\n内存中一个字需要2个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n\n任何2个地址连续的内存单元，N单元和N+1号单元，可以将它们看成2个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。\n\n**在读写中，默认指定的单元地址为低位地址**\n\n<!--more-->\n\n## DS和[address]\n\n内存地址由段地址和偏移地址组成\n\nDS[Data Segment]数据段寄存器，用来存放要访问数据的段地址\n\n例如：读取10000H单元的内容\n\n```assembly\nmov bx,1000H\nmov ds,bx\nmov al,[0]\n```\n\n在`mov al,[0]`中[0]为内存单元的地址，该内存单元的地址由DS中存储的段地址和[]间的偏移地址组成\n\n即，[N]的物理地址为 DSx16+N\n\n**在8086CPU中不支持将数据(立即数)直接送入段寄存器中，需要一个寄存器进行中转**\n\n## 字的传送\n\n由于8068cpu拥有16条数据总线，所以一次性最大传送16位的数据即一个字的数据\n\n所以对于16位的寄存器如AX则在使用mov操作时，能传送一个字的数据\n\n## mov、add、sub指令\n\n### mov\n\n| **mov 指令的形式** |          |          |\n| ------------------ | -------- | -------- |\n| mov                | 寄存器   | 数据     |\n| mov                | 寄存器   | 寄存器   |\n| mov                | 寄存器   | 内存单元 |\n| mov                | 内存单元 | 寄存器   |\n| mov                | 内存单元 | 段寄存器 |\n| mov                | 段寄存器 | 寄存器   |\n| mov                | 寄存器   | 段寄存器 |\n| mov                | 段寄存器 | 内存单元 |\n\n**PS：这与不能将数据放入到段寄存器中不一样，这不是立即数**\n\n### add与sub\n\n除了不能操作段寄存器中是数据，其指令结构与mov类似\n\n## 数据段\n\n可以将内存中连续的一段数据定义为数据段\n\n## 栈\n\n**栈是一种具有特殊的访问方式的存储空间**\n\nCPU使用段寄存器SS和寄存器SP来定义和维护一个栈\n\n**栈顶**的段地址放在SS中，偏移地址放在SP中\n\n**任意时刻，SS:SP指向栈顶元素**\n\n栈空时，SP指向栈底元素的下一个单元的位置（一个字）的位置\n\n## 栈顶超界问题\n\n栈顶超界可以分为上超界和下超界\n\n8086CPU并不提供任何检测机制来检测或者辅助检测超界，所以编程时必须要要谨慎使用栈空间\n\n## push和pop指令\n\npush和pop指令均可以对内存单元 寄存器 以及段寄存器进行操作\n\n## 栈段\n\n类似与代码段和数据段，我们可以定义栈段。\n\n通过修改CPU中的SS:SP来让cpu接受我们的定义\n\n","tags":["笔记","汇编","assembly x86_64","寄存器"],"categories":["笔记","assembly x86_64","3-寄存器(内存访问)"]},{"title":"2-Debug的使用","url":"/posts/768629/","content":"\n## win10环境下的汇编环境的配置\n\n1. 安装DosBox\n2. 创建一个用于虚拟DosBox的目录，并在其中放入MASM的环境套件\n3. 在DosBox的配置文件中，自动挂载上述目录 mount c: 目录\n4. 这样形成的dos环境为保护模式下的dos环境\n\n## Debug的相关命令\n\n![image-20210804162136131](2-Debug%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210804162136131.png)\n\n","tags":["笔记","汇编","assembly x86_64"],"categories":["笔记","assembly x86_64","2-Debug的使用"]},{"title":"1-寄存器","url":"/posts/263842aa/","content":"## 通用寄存器\n\n每个cpu都有自己的寄存器，如8060CPU有14个寄存器：AX BX CX DX SI DI SP BP IP CS SS DS ES PSW。\n\nAX BX CX DX用来存放一般数据被称为通用寄存器\n\n<!--more-->\n\n## 字在寄存器中的存储\n\n1字节（byte） = 8位（bit）\n\n在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）\n\n在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit）\n\n在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit）\n\n## 几条汇编指令\n\n**汇编指令不区分大小写**\n\n| 汇编指令 | 控制CPU完成的操作 | 用高级语言的语法描述 |\n| :------: | :--: | :--: |\n| mov ax,18 | 将18送入AX | AX=18 |\n| mov ah,78 | 将78送入AH | AH=78 |\n| add ax,8 | 将寄存器AX中的数值加上8 | AX=AX+8 |\n| mov ax,bx | 将BX中的数据送入AX | AX=BX |\n| add ax,bx | 将BX中的值加到AX上并存入AX | AX=AX+BX |\n\n如果寄存器结果溢出，则将最高位存入特地的进位区\n\n## 物理地址\n\n内存单元在内存空间中的唯一地址为物理地址\n\n## 16位结构的CPU\n\n- 运算器一次最多能处理16位数据\n- 寄存器的最大宽度为16位\n- 寄存器和运算器之间的通路为16位\n\n## 8086给出物理地址的方法\n\n8086CPU对外部有20位的地址总线，可以传送20位的地址，而内部又是16位的结构。\n\n8086CPU采用内部将2个16位地址合成为一个20位地址的方法：\n\n![image-20210804135201812](1-%E5%AF%84%E5%AD%98%E5%99%A8/image-20210804135201812.png)\n\n## 地址加法器的工作原理\n\n![image-20210804135214118](1-%E5%AF%84%E5%AD%98%E5%99%A8/image-20210804135214118.png)\n\n用2个16位地址来形成一个20位地址\n\n**一个结果有多种组合输入**\n\n## 段的概念\n\n内存并没有分段，而是由于CPU寻址采用**物理地址=段地址x16+偏移地址**的方式来合成物理地址\n\n所以段地址的基址定是16的倍数，一个段最大为16位寻址能力的64KB\n\n用段地址指定内存的段的起始地址，用偏移地址来获取段中的内存单元\n\n## 段寄存器\n\n8086有4个段寄存器：\n\nCS(Code Segment:代码段寄存器) \nDS(Data Segment:数据段寄存器) \nSS(Stack Segment:数据段寄存器) \nES(Extra Segment:附加段寄存器)\n\n## CS和IP\n\n在8086机中任意时刻，设CS为M IP为N则8086CPU将从内存Mx16+N的单元开始读取一条指令并执行\n\n8086机中，任意时刻CPU将CS:IP指向的内容当作指令执行\n\n## 修改CS、IP的指令\n\n使用jmp指令来修改CS和IP寄存器的值\n\njmp 段地址:偏移地址\n\njmp M:N 执行后 CS=M，IP=N（均为16进制）\n\njmp N（可以为合法寄存器） 执行后 CS不变 IP=N\t（均为16进制）\n\n## 代码段\n\n将连续的，存放代码的内存段逻辑上认为为代码段。\n\n\n\n\n\n","tags":["笔记","汇编","assembly x86_64","寄存器"],"categories":["笔记","assembly x86_64","1-寄存器"]},{"title":"0-汇编概论","url":"/posts/24b6c9f3/","content":"## 什么是汇编语言\n\n汇编语言是最古老的编程语言，在所有的语言中，它与原生机器语言最为接近。它能直接访问计算机硬件，要求用户了解计算机架构和操作系统。\n\n汇编语言直接在硬件上运行，效率高\n\n<!--more-->\n\n## 汇编语言是如何工作的\n\n- **汇编器(assembler)**:汇编器是一种工具程序将汇编语言程序转换为机器语言\n- **链接器(linker)**:链接器是一种工具程序将汇编器生成的单个文件组合为一个可执行程序\n- **调试器(debugger)**:用于程序运行时的寄存器检查和内存检查\n\n## 基础知识\n\n1. 机器指令\n2. 操作\n3. 汇编指令\n4. 寄存器:cpu中存储数据的器件有特定的代号\n\n## 三条总线\n\n1. 数据总线\n2. 地址总线\n3. 控制总线\n\n","tags":["笔记","汇编","assembly x86_64","概论"],"categories":["笔记","assembly x86_64","0-汇编概论"]},{"title":"考试周破防","url":"/posts/b5d31d08/","content":"\n\n## 2021-06-27考试周开始的前一天\n\n明天就考学术英语了，但是英语一点都没看啊，十分的紧张，压力如同五行山一般压的我头疼欲裂。我感到很那么，考四级时全裸考都没这么有压力，一个学术英语为什么能让我感到压力山大呢，我无从寻解。\n\n<!--more-->\n\n昨夜，在入睡前想着明天要早起，好好复习，不要拉了胯，于是今天早上九时从奇幻冒险片中抽出神来，从枕下摸出手机，打开那B站。待回过神，已是十时差一刻，自觉应当抓紧起来复习了。匆匆下了床，匆匆洗漱，再匆匆收拾昨日桌上的残局。好容易收拾完觉得可以开始了，瞄一眼手机，十时整好。\n\n看到如此整点的时间，心中难免觉得愉悦，但又不敢过于愉悦，如同老鼠偷油，稍稍沾点甜头，便警惕的收回心来。严肃的打开电脑，点开日程管理工具，边带着愧疚边安慰自己地将昨日未打的卡给打上，也不知是为了什么。翻到今日的时间轴，看着已经走到十时三分的红线，已经略过的\"背单词\"，明日的学术英语考试，后日的微积分，大后日的......整整一周的考试以及右侧未完成的复习计划，心中更加暗暗的告诫自己要收心·、复习，不要重蹈覆辙。\n\n于是开始安排，将略过的\"背单词\"拉到红线之后，不料程序自动吸附到了十时，着实另我感到难受，若就这样，那已经超过四分钟，觉得没有好好的开头，若向后继续拉，则恰好吸附到一刻处，则距离开始还有不少的时间难免有些浪费，再瞄一眼系统时间，10时5分，挺整一个数，那还是让它从十时开始吧。在这之后，\"课文复习\"、\"听力\"……最终满意的安排完了，心中想着今天必是充实的一天，不免感到有些轻松起来。\n\n可是好巧不巧，想必是晚上着了凉，或者没吃早饭，肚子开始难受起来，急忙抄起手机和纸前去解决。选位，调整好姿势，打开B站。带回过神瞄到时间，赫然是10点半了，内心大嘘，急忙处理后事往书桌前奔赴。\n\n点开背单词的网页，心中又冒出应该整个平板的想法，\"等这学期结束吧\"，我安慰自己。一个一个的记单词，总计60个，开始的前29个，仔仔细细、认认真真、十分负责的记完，看着快过半的进度，又瞄了一眼时间10:48，再看看日程表上安排的时间，顿时紧张起来，只有12分钟了，于是开始加快速度。最终，在11时04分结束，还算满意的将这个任务从表上勾掉。\n\n吃完午饭，看着给自己安排的一个小时的午休时间还有半个小时，心中难免开始痒痒，纠结起来是否要打开游戏给自己\"放松\"一下，最终还是打开了《浮岛物语》,当时我就想着就玩30分钟，到点就开始复习听力，结果不料游戏设计师真的狡猾，而且竟然还遇到bug，着实让我闹心，全网找解决方法，结果最终也没得结果。从脑热中冷静下来，一看时间，沃日13:32。溜大了，内心狠狠的谴责了自己一波，还是火急火燎的复习起听力。\n\n有了这一出，大脑内生物噪声极剧增大，双耳所听，难得其解 ，心中难免升起对自己旧时没有好好学英语的懊悔，但深知懊悔无用，遂欲向群友寻求帮助。哪里想得根本无得，最终反而过了14时。心如死灰，觉得还是躺平罢，别卷了，如是安慰自己。突然恶疾发作，难以忍受，急忙打开B站找到[《猫中毒》](https://www.bilibili.com/video/BV1FX4y1g7u8?share_source=copy_web)才得以缓解片刻，深感这样不行，于是又打开《浮岛物语》妄图以毒攻毒，就这样熬到了晚饭饭点。\n\n饭后，看着完全没有完成的下午计划，起了破罐破摔的意图，又打开的《浮岛物语》，一边玩一边紧张，觉得应当早点结束，打开CE开始了对其的一顿查找排查。最终3个多小时过去了，到了晚上8点半。从褪出脑热状态的我，看着满目疮痍的计划表，再想着明日的考试，有点口干舌燥，伸手去拿水杯，发现并没有谁，气不打一处来。着实破防了。\n\n还好学术英语不算绩点，想起这点的我着实觉得松了一口气，心中想着，后日乃至之后的考试定要好好准备，便抄起水杯前去泡蜂蜜水去了……\n\n(待续)\n\n","tags":["感概"],"categories":["感慨"]},{"title":"数据结构-第七次解题报告","url":"/posts/43cd80f5/","content":"\n\n## 第一题:序列调度\n\n有一个N个数的序列A：1，2，……，N。有一个后进先出容器D，容器的容量为C。如果给出一个由1到N组成的序列，那么可否由A使用容器D的插入和删除操作得到。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第七次解题报告/1.png\">\n\n第1行，2个整数T和C，空格分隔，分别表示询问的组数和容器的容量，1≤T≤10，1≤C≤N。\n\n第2到T+1行，每行的第1个整数N，表示序列的元素数，1≤N≤10000。接下来N个整数，表示询问的序列。\n\n### 输出格式\n\nT行。若第i组的序列能得到，第i行输出Yes；否则，第i行输出No,1≤i≤T。\n\n### 输入样例\n\n```data\n2 2\n5 1 2 5 4 3\n4 1 3 2 4\n\n```\n\n### 输出样例\n\n```data\nNo\nYes\n\n```\n\n<!--more-->\n\n### 题目解析\n\n分析题意，我们可以想到题目的目的是验证一个固定容量的栈能否将辅助输出对应的序列。起先我注意到这可能更逆序数有关，但局限于贫乏的数学能力，我觉得使用暴力模拟来验证更加可靠。\n\n#### 方法一:模拟法\n\n因为原序列是连续序列，所以并不需要开一个数组来存序列，可以节省点空间，节约初始化时间。\n\n使用一个栈，在读入输出序列时，若读入的数并不是现在顺序序列中指向的数，那显然顺序序列中的该数应该入栈，同时若读入的数小于先顺序序列中指向的数，那显然的，所需的数应在栈中寻找，若在栈顶则可及，否则不可及。\n\n若爆栈，那显然也不可及\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    vector<int> temp;\n    int t=0, c=0;\n    scanf(\"%d %d\",&t,&c);getchar();\n    for (int i = 0; i < t; ++i)\n    {\n        int top=1;\n        bool flag=true;\n        temp.clear();\n        int n=0;\n        scanf(\"%d\",&n);\n        int k=0;int j=0;\n        for (j = 0; j < n; ++j){\n            scanf(\"%d\",&k);\n            if(!flag)continue;\n            while (k>=top){\n                temp.push_back(top);\n                ++top;\n            }\n            if(k==top){\n                ++top;\n                continue;\n            }\n            if(temp.size()>c){\n                flag=false;\n                continue;\n            }\n            if(k<top){\n                if(k==temp.back()){\n                    temp.pop_back();\n                    continue;\n                }else{\n                    flag=false;\n                    continue;\n                }\n            }\n            \n        }\n        \n        printf(\"%s\",flag?\"Yes\":\"No\");\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n```\n\n##### 分析\n\n显然的，时间复杂度是O(n)，比较迅速。而且不用数组存储序列，较为节省空间\n\n#### ~~方法二:遍历解空间~~\n\n可以将一个序列所以的可能建图，然后遍历验证。（溜~\n\n## 第二题:最大最小差\n\n对n 个正整数，进行如下操作：每一次删去其中两个数 a 和 b，然后加入一个新数：a*b+1，如此下去直到 只剩下一个数。所有按这种操作方式最后得到的数中，最大的为max，最小的为min，计算max-min。\n\n### 输入格式<img align=\"right\" src=\"数据结构-第七次解题报告/2.png\">\n\n第1行：n，数列元素的个数，1<=n<=16。\n\n第2行：n 个用空格隔开的数x，x<=10。\n\n### 输出格式\n\n1行，所求max-min\n\n### 输入样例\n\n```data\n3\n2 4 3\n\n```\n\n### 输出样例\n\n```data\n2\n\n```\n\n### 题目解析\n\n存在一个规律，不断的取最小的2个数进行操作，那最终的结果就是最大的，同样的，不断的取最大的2个数进行操作，那最终的结果就是最小的。\n\n#### 方法一:利用规律\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\npriority_queue<long long,vector<long long>,less<long long>> big;\npriority_queue<long long,vector<long long>,greater<long long>> small;\n\nint main(int argc, char const *argv[])\n{\n    int n=0,t=0;\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\",&t);\n        big.push(t);\n        small.push(t);\n    }\n    while (big.size()!=1)\n    {\n        long long a=big.top();\n        big.pop();\n        long long b=big.top();\n        big.pop();\n        big.push(a*b+1);\n    }\n    while (small.size()!=1)\n    {\n        long long a=small.top();\n        small.pop();\n        long long b=small.top();\n        small.pop();\n        small.push(a*b+1);\n    }\n    printf(\"%lld\\n\",small.top()-big.top());\n    \n    return 0;\n}\n\n```\n\n##### ~~分析~~\n\n没什么好分析的，写的很随便\n\n## 第三题:二叉树最短路径长度\n\n给定一棵二叉树T，每个结点赋一个权值。计算从根结点到所有结点的最短路径长度。路径长度定义为：路径上的每个顶点的权值和。\n\n### 输入格式<img align=\"right\" src=\"数据结构-第七次解题报告/3.png\">\n\n第1行，1个整数n，表示二叉树T的结点数，结点编号1..n，1≤n≤20000。\n\n第2行，n个整数，空格分隔，表示T的先根序列，序列中结点用编号表示。\n\n第3行，n个整数，空格分隔，表示T的中根序列，序列中结点用编号表示。\n\n第4行，n个整数Wi，空格分隔，表示T中结点的权值，-10000≤Wi≤10000，1≤i≤n。\n\n### 输出格式\n\n1行，n个整数，表示根结点到其它所有结点的最短路径长度。\n\n### 输入样例\n\n```data\n4\n1 2 4 3\n4 2 1 3\n1 -1 2 3\n\n```\n\n###  输出样例\n\n```data\n1 0 3 3\n```\n\n### 题目解析\n\n简单分析可知，此题关键在于从中根序和先根序中得出树的信息\n\n#### 方法一:建树法\n\n直接利用蕴藏的信息建树\n\n```c++\n#include<iostream>\n#define N 20010\n\nusing namespace std;\n\nint Left[N];\nint Right[N];\nint weight[N];\nint res[N];\nint a[N];\nint b[N];\n\nint n=0;\nint p=0;\n\nint initTree(int al,int ar){\n    if(al>ar){\n        return 0;\n    }\n    ++p;\n    if(al==ar){\n        return b[ar];\n    }\n\n    int root=0;\n    int mid=0;\n    for(mid=al;mid<=ar;++mid){\n        if(b[mid]==a[p]){\n            root=a[p];\n            break;\n        }\n    }\n    //建立左子树\n    Left[root]=initTree(al,mid-1);\n    Right[root]=initTree(mid+1,ar);\n    return root;\n}\n\nvoid DFS(int root,int cost){\n    if(root==0)return;\n    res[root]=cost+weight[root];\n    DFS(Left[root],res[root]);\n    DFS(Right[root],res[root]);\n}\n\n\nint main(int argc, char const *argv[])\n{\n    scanf(\"%d\",&n);\n    for (int i = 1; i <=n; ++i){\n        scanf(\"%d\",&a[i]);\n    }\n    for (int i = 1; i <=n; ++i){\n        scanf(\"%d\",&b[i]);\n    }\n    int root=initTree(1,n);\n    for (int i = 1; i <=n; ++i)\n    {\n        scanf(\"%d\",&weight[i]);\n    }\n    DFS(root,0);\n    for (int i = 1; i <=n; ++i){\n        printf(\"%d%c\",res[i],i<n?' ':'\\n');\n    }\n    \n    return 0;\n}\n\n```\n\n##### 分析\n\n考虑到建树的代价，所以时间复杂度是O(n)的。使用了较为优的建树法，提高了效率。\n\n## 第四题:方案计数\n\n组装一个产品需要 n 个零件。生产每个零件都需花费一定的时间。零件的生产可以并行进行。有些零件的生产有先后关系，只有一个零件的之前的所有零件都生产完毕，才能开始生产这个零件。如何合理安排工序，才能在最少的时间内完成所有零件的生产。在保证最少时间情况下，关键方案有多少种，关键方案是指从生产开始时间到结束时间的一个零件生产序列，序列中相邻两个零件的关系属于事先给出的零件间先后关系的集合，序列中的每一个零件的生产都不能延期\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第七次解题报告/4.png\">\n\n第1行，2个整数n和m，用空格分隔，分别表示零件数和关系数，零件编号1..n，1≤n≤10000, 0≤m≤100000 。\n\n第2行，n个整数Ti，用空格分隔，表示零件i的生产时间，1≤i≤n，1≤Ti≤100 。\n\n第3到m+2行，每行两个整数i和j，用空格分隔，表示零件i要在零件j之前生产。\n\n### 输出格式\n\n第1行，1个整数，完成生产的最少时间。\n\n第2行，1个整数，关键方案数，最多100位。\n\n如果生产不能完成，只输出1行，包含1个整数0.\n\n### 输入样例\n\n```data\n4 4\n1 2 2 1\n1 2\n1 3\n2 4\n3 4\n```\n\n### 输出样例\n\n```data\n4\n2\n\n```\n\n### 题目解析\n\n经过分析，题目表达2点意思。\n\n1. 求出关键路径的长度\n2. 求出所有关键路径\n\n题面给出的是AOV网，因而引入虚源和虚汇，并将对应的点权向前推为边权。\n\n对于第一点，比较简单，只需要对AOE网跑一遍关键路径算法即可\n\n对于第二点，考虑到题目给出结果有<font color=FF0000>100位</font>，所以我们不得不用高精度加法来确保结果能够正确。\n\n#### 方法一:基于递推\n\n对于求关键路径的条数，使用递推的方式来求。即为了求到虚汇的关键路径条数，我们可以求所以到虚汇的关键节点的关键路径条数，然后将这些数相加，即可得到虚汇的关键路径条数，以此类推。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\nusing namespace std;\n\n/*<---------------------高精度加法------------------------->*/\nclass BigInteger\n{\nprivate:\n    vector<int> content;\npublic:\n    BigInteger();\n    BigInteger(long long origin);\n    BigInteger(const BigInteger& b);\n    ~BigInteger();\n    unsigned long long size() const;\n    BigInteger operator+(const BigInteger& b);\n    BigInteger& operator=(const BigInteger& b);\n    void resize(unsigned long long n); \n    const int& operator[](unsigned long long i)const;\n    int& operator[](unsigned long long i);\n    string toString();\n\n};\nBigInteger::BigInteger(){\n    content.reserve(128);\n    for (int i = 0; i < 128; ++i){\n        content.push_back(0);\n    }\n    \n}\n\nBigInteger::BigInteger(long long origin){\n    content.reserve(128);\n    while (origin>0)\n    {\n        content.push_back(origin%10);\n        origin=origin/10;\n    }\n}\nBigInteger::BigInteger(const BigInteger& b){\n    content.clear();\n    for(int i=0;i<b.size();++i){\n        content.push_back(b[i]);\n    }\n}\n\nBigInteger::~BigInteger(){\n    content.clear();\n}\n\nBigInteger BigInteger::operator+(const BigInteger& b){\n    BigInteger t;\n    BigInteger res;\n    unsigned long long maxsize=max(this->size(),b.size());\n    t.resize(maxsize+1);\n    res.resize(maxsize+1);\n    for (int i = 0; i < maxsize; ++i){\n        int num1=i<this->size()?content[i]:0;\n        int num2=i<b.size()?b[i]:0;\n        res[i]=(num1+num2+t[i])%10;\n        t[i+1]=(num1+num2+t[i])/10;\n    }\n    if(t[maxsize]!=0){\n        res[maxsize]=t[maxsize];\n    }else{\n        res.resize(maxsize);\n    }\n    return res;\n}\nBigInteger& BigInteger::operator=(const BigInteger& b){\n    if(this==&b){\n        return *this;\n    }else{\n        content.clear();\n        content.reserve(b.size());\n        for(int i=0;i<b.size();++i){\n            content.push_back(b[i]);\n        }\n    }\n    return *this;\n}\nunsigned long long BigInteger::size()const{\n        return content.size();\n}\nconst int& BigInteger::operator[](unsigned long long i)const{\n    if(i>content.size())return *content.end();\n    return (*(content.begin()+i));\n}\nint& BigInteger::operator[](unsigned long long i){\n    if(i>content.size())return *content.end();\n    return (*(content.begin()+i));\n}\nvoid BigInteger::resize(unsigned long long n){\n    if(n>this->size()){\n        for (unsigned long long i = this->size(); i <n; ++i){\n            content.push_back(0);\n        }\n    }else{\n        for (unsigned long long i = this->size(); i>n; --i){\n            content.pop_back();\n        }\n    }\n}\nstring BigInteger::toString(){\n    bool flag=true;\n    string res;\n    for (int i = this->size()-1; i >=0; --i){\n        if(flag&&content[i]==0){\n            continue;\n        }else{\n            if(flag&&content[i]!=0){\n                flag=false;\n            }\n            res.push_back(content[i]+48);\n        }\n    }\n    if(flag)res.push_back('0');\n    return res;\n}\n/*<!--------------------高精度加法------------------------->*/\n#define MAXN 10010\nint n=0;\nint m=0;\n/*<---------------------读入AOV图-------------------------->*/\nstruct Edge\n{\n    int u;\n    int v;\n    int w;\n    Edge* next;\n    Edge(){v=0;w=0;next=nullptr;}\n    Edge(int _u,int _v,int _w){u=_u;v=_v;w=_w;next=nullptr;}\n};\nstruct Node\n{\n    int inDegree;\n    int inDegree_for_bfs;\n    int outDegree;\n    int cost;\n    int ES;\n    int LS;\n    Edge *next;\n    Node(){\n        inDegree=0;outDegree=0;\n        cost=0;\n        ES=0;LS=__INT32_MAX__;  //初始化最早和最晚开始时间\n        next=nullptr;\n    }\n};\n\nNode head[MAXN];\nvoid addEdge(int u,int v,int cost){\n    Edge* t=head[u].next;\n    head[u].next=new Edge(u,v,cost);\n    if(t!=nullptr){\n        head[u].next->next=t;\n    }\n    head[u].outDegree+=1;\n    head[v].inDegree+=1;\n    head[v].inDegree_for_bfs+=1;\n}\nvoid input_map(){\n    for (int i = 1; i <=n; ++i){\n        scanf(\"%d\",&head[i].cost);\n    }\n    int u=0,v=0;\n    for (int i = 0; i < m; ++i){\n        scanf(\"%d %d\",&u,&v);\n        addEdge(u,v,head[v].cost);  //将点权前推到边上\n    }\n    //引入虚源虚汇\n    for (int i=1;i<=n;++i){\n        if(head[i].inDegree==0){\n            //将虚源指向入度为0的点\n            addEdge(0,i,head[i].cost);\n        }\n        if(head[i].outDegree==0){\n            //将出度为0点指向虚汇\n            addEdge(i,n+1,0);\n        }\n    }\n}\n/*<!--------------------读入AOV图-------------------------->*/\n\n/*<---------------------拓扑排序与关键路径---------------------------->*/\n\n//拓扑排序\nvector<int> topRes; //存放拓扑排序的结果\nvoid topOder(){\n    //初始化\n    queue<int> q;\n    topRes.reserve(MAXN);\n    q.push(0);  //虚源定入度为0\n    //开始拓扑\n    while (!q.empty()){\n        int cur=q.front();\n        q.pop();\n        topRes.push_back(cur);\n        //遍历\n        for (auto i = head[cur].next; i!=nullptr;i=i->next){\n            int v=i->v;int w=i->w;\n            if((--head[v].inDegree)==0){\n                q.push(v);\n                //cout << v << endl;\n            }\n            head[v].ES=max(head[cur].ES+w,head[v].ES);  //顺着拓扑排序，求出最活动的最早开始时间\n            //cout<<head[v].ES<<endl;\n        }\n    }\n}\n\n//关键路径算法\nvoid CritiaclPath(){\n    topOder();  //顺推求出所有的最早发生时间\n    head[n+1].LS=head[n+1].ES;  //将顺推的结果作为逆推的开头\n    //开始逆推\n    for(int i=topRes.size()-1;i>=0;--i){\n        int cur=topRes[i];\n        for (auto j = head[cur].next; j!=nullptr;j=j->next){\n            int v=j->v;int w=j->w;\n            head[cur].LS=min(head[v].LS-w,head[cur].LS);    //逆拓扑序，求出活动的最迟开始时间\n            //cout<<head[cur].LS<<endl;\n        }\n    }\n}\n\n/*<!--------------------拓扑排序与关键路径---------------------------->*/\n\n/*<---------------------利用BFS递推来求出结果------------------------->*/\nBigInteger temps[MAXN]; //用于存放到达每个节点的关键路径\nBigInteger final;   //存放最终结果\nint visited[MAXN];  //用于区分节点是否已经被计算过\n\nvoid BFS(int x){\n    queue<int> q;   //暂存层\n    q.push(x);\n    visited[x]=1;\n    while (!q.empty()){\n        int cur=q.front();\n        q.pop();\n        visited[cur]=1;\n        for (auto i = head[cur].next; i!=nullptr;i=i->next){\n            int v=i->v;\n            head[v].inDegree_for_bfs-=1;\n            //则指向节点为关键节点，该路径为关键路径\n            if(head[v].ES==head[v].LS){\n                temps[v]=temps[cur]+temps[v];\n            }\n            if(head[v].inDegree_for_bfs==0){\n                q.push(v);\n            } \n        }\n        \n    }\n}\n\n\n\n/*<!--------------------利用BFS递推来求出结果------------------------->*/\n\nint main(int argc, char const *argv[])\n{\n    scanf(\"%d %d\",&n,&m);\n    input_map();    //读入AOV图\n    CritiaclPath(); //求出关键路径上的时间\n    temps[0]=1; //认为到虚源有一条关键路径\n    BFS(0);\n    long long res=head[n+1].ES;\n    final=temps[n+1];\n    if(final.toString()!=\"0\")cout<<res<<endl;\n    cout<<final.toString()<<endl;\n    return 0;\n}\n\n```\n\n##### 分析\n\n精细封装了一个高精度的加法，便于后续使用。对于时间复杂度分析不能。\n\n## 总结\n\n总体来说此次实验的卡点就在于最后一题的高精度加法，对于此，平常应当积累些代码模板，以便于使用。\n\n","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第七次解题报告"]},{"title":"数据结构-第六次解题报告","url":"/posts/b06eb357/","content":"\n\n## 第一题:高精度数加法\n\n高精度数是指大大超出了标准数据类型能表示的范围的数，例如10000位整数。很多计算问题的结果都很大，因此，高精度数极其重要。\n\n一般使用一个数组来存储高精度数的所有数位，数组中的每个元素存储该高精度数的1位数字或多位数字。 请尝试计算：N个高精度数的加和。这个任务对于在学习数据结构的你来说应该是小菜一碟。 。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第六次解题报告/1.png\">\n\n第1行，1个整数N，表示高精度整数的个数，(1≤N≤10000)。\n\n第2至N+1行，每行1个高精度整数x, x最多100位。\n\n### 输出格式\n\n1行,1个高精度整数，表示输入的N个高精度数的加和。\n\n### 输入样例\n\n```data\n3\n12345678910\n12345678910\n12345678910\n\n```\n\n### 输出样例\n\n```data\n37037036730\n\n```\n<!--more-->\n\n### 题目解析\n\n也没什么好说的吧，就是用数组来模拟加法的逐位运算，唯一要注意的是开的数组的大小要比上限多一位。其次是输入应该逆序\n\n#### 代码实现\n\n```c++\n#include<iostream>\n#include<string>\n#define N 111\nusing namespace std;\n\n\nvoid add(int x[],int y[],int z[]){\n    for(int i=0;i<N;++i){\n        z[i+1]=(x[i]+y[i]+z[i])/10;\n        x[i]=(x[i]+y[i]+z[i])%10;\n    }\n}\nint a[N]={0};\nint b[N]={0};\nint t[N]={0};\nstring temp;\nint main(int argc, char const *argv[])\n{\n    temp.clear();\n    int n=0;\n    cin>>n;\n    for(int i=0;i<n;++i){\n        int j=0;\n        cin>>temp;\n        for (int i = temp.size()-1; i>=0; --i)\n        {\n            b[j]=temp[i]-48;\n            ++j;\n        }\n        add(a,b,t);\n        for(int i=0;i<j;++i){\n            b[i]=0;\n        }\n    }\n    bool flag=true;\n    for(int i=N-1;i>=0;--i){\n        if(flag&&a[i]!=0){\n            printf(\"%d\",a[i]);\n            flag=false;\n        }else if (!flag)\n        {\n            printf(\"%d\",a[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n```\n\n## 第二题:二叉树的加权距离\n\n二叉树结点间的一种加权距离定义为：上行方向的变数×3 +下行方向的边数×2 。上行方向是指由结点向根的方向，下行方向是指与由根向叶结点方向。 给定一棵二叉树T及两个结点u和v，试求u到v的加权距离。\n\n### 输入格式  <img align=\"right\" src=\"数据结构-第六次解题报告/2.png\">\n\n第1行，1个整数N，表示二叉树的结点数，(1≤N≤100000)。\n\n随后若干行，每行两个整数a和b，用空格分隔，表示结点a到结点b有一条边，a、b是结点的编号，1≤a、b≤N；根结点编号为1，边从根向叶结点方向。\n\n最后1行，两个整数u和v，用空格分隔，表示所查询的两个结点的编号，1≤u、v≤N。\n\n### 输出格式\n\n1行,1个整数，表示查询的加权距离。\n\n### 输入样例\n\n```data\n5\n1 2\n2 3\n1 4\n4 5\n3 4\n\n```\n\n### 输出样例\n\n```data\n8\n\n```\n\n### 题目解析\n\n本质上是图上2点的路径问题，且因为这是树，所以我们可以利用树的特殊性来解，或者使用图的普遍方法来解\n\n#### 方法一:树上节点到根必有路径\n\n因为根据树的性质，任意节点到根定有路径，所以我们可以求出2个点各自到根的路径，那必然会交汇，从而形成路径。\n\n需要注意，退化树情形下的特判。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#define N 100001\n\nusing namespace std;\n\nint parent[N];\nint path[N]={0};\n\nint main(int argc, char const *argv[])\n{\n\n    int n=0;\n    scanf(\"%d\",&n);getchar();\n    int u=0,v=0;\n    for (int i = 0; i < n-1; i++)\n    {\n        scanf(\"%d %d\",&u,&v);getchar();\n        parent[v]=u;\n    }\n    scanf(\"%d %d\",&u,&v);\n    int orgin_u=u;\n    int up=0,down=0;\n    //u向上走并更新path\n    while (parent[u]!=0){\n        path[parent[u]]=path[u]+1;\n        if(parent[u]==v){\n            up=path[u]+1;\n            break;\n        }\n        u=parent[u];\n    }\n    //v向上走并更新path,若遇到已经大于0的path则证明找到通路\n    while (parent[v]!=0&&up==0)\n    {\n        if(!path[parent[v]]){\n            path[parent[v]]=path[v]+1;\n        }else{\n            up=path[parent[v]];\n            down=path[v]+1;\n            break;\n        }\n        if(parent[v]==orgin_u){\n            down=path[v]+1;\n            break;\n        }\n        v=parent[v];\n    }\n    printf(\"%lld\\n\",(long long)up*3+down*2);\n\n    \n    return 0;\n}\n\n```\n\n##### 分析\n\n因为都是从节点到根的过程，可以直接看出最坏时间为T(n)=$2\\log_2n$，所以时间复杂度为O（$\\log_2n$)，还是比较好写且快速的。\n\n#### 方法二:利用图的单源最短路\n\n因为树也是图的一种，那么只需要对一点使用单源最短路，并对路径的类型进行加权运算，即可得出答案\n\n##### ~~代码实现~~\n\n## 第三题:修轻轨\n\n长春市有n个交通枢纽，计划在1号枢纽到n号枢纽之间修建一条轻轨。轻轨由多段隧道组成，候选隧道有m段。每段候选隧道只能由一个公司施工，施工天数对各家公司一致。有n家施工公司，每家公司同时最多只能修建一条候选隧道。所有公司可以同时开始施工。请评估：修建这条轻轨最少要多少天。。\n\n### 输入格式 <img  align=\"right\" src=\"数据结构-第六次解题报告/3.png\">\n\n第1行，两个整数n和m，用空格分隔，分别表示交通枢纽的数量和候选隧道的数量，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000。\n\n第2行到第m+1行，每行三个整数a、b、c，用空格分隔，表示枢纽a和枢纽b之间可以修建一条双向隧道，施工时间为c天，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。\n\n### 输出格式\n\n输出一行，包含一个整数，表示最少施工天数。\n\n### 输入样例\n\n```data\n6 6\n1 2 4\n2 3 4\n3 6 7\n1 4 2\n4 5 5\n5 6 6\n\n```\n\n### 输出样例\n\n```data\n6\n\n```\n\n### 题目解析\n\n此题乍一看好像是关键路径问题，但是，有个提示：<font color=\"FF0000\">并不是每个枢纽都必须经过</font>，也就是说，只要找出连接起点和终点的一条路即可，而所求时间就是这路上最迟完成的时间。\n\n所以本质上是某种最小生成树问题，或者说是最短路径问题，因而可以从2种思路来解题\n\n#### 方法一:Kruskal(MST)\n\n因为最终我们只需要2点连通，且连通路最小，因而可以使用稍作修改的Kruskal来寻找。但存在一个问题，如何保证答案必定存在，且正确呢？我们可以简单的作下思维实验和推理\n\n首先可以确定的是，连通路必定存在，若不存在则无解。其次如何保证最小，因为Kruskal每次取最小边，假如取了一条边后使得，起点和终点连通，即刻停止算法，则可以肯定，不会存在更大的路径。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct Object\n{\n    int u;\n    int v;\n    int cost;\n    Object(){\n        u=0;v=0;cost=0;\n    }\n    Object(const Object &x){\n        u=x.u;v=x.v;cost=x.cost;\n    }\n    Object(int _u,int _v,int _cost):\n    u(_u),v(_v),cost(_cost){\n    }\n    bool operator<(const Object& b)const{\n        return cost>b.cost;\n    }\n};\n//边集\npriority_queue<Object> edges;\n\n//并查集部分\nvector<int> father;\n//并查集初始化\nvoid make_set(int n){\n    for (int i = 0; i <=n; ++i)\n    {\n        father.push_back(0);\n    }\n}\n//并查集查找\nint Find(int v){\n    if(father[v]<=0)return v;\n    return father[v]=Find(father[v]);   //路径压缩\n}\n//并查集合并\nvoid Union(int x,int y){\n    int fx=Find(x);\n    int fy=Find(y);\n    if(fx!=fy){\n        father[fy]=fx;\n    }\n}\n\n\nint main(int argc, char const *argv[])\n{\n    int n=0,m=0;\n    scanf(\"%d %d\",&n,&m);\n    make_set(n);\n    int u=0,v=0,cost=0;\n    for(int i=0;i<m;++i){\n        scanf(\" %d %d %d\",&u,&v,&cost);\n        edges.push(Object(u,v,cost));\n    }\n    //Kruskal\n    int res=0;\n    while (!edges.empty())\n    {\n        Object t=edges.top();\n        edges.pop();\n        if(Find(t.u)!=Find(t.v)){\n            Union(t.u,t.v);\n        }\n        if(Find(1)==Find(n)){\n            res=t.cost;\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n\n```\n\n##### 分析\n\n因为并查集使用了路径压缩，考虑到最坏时间复杂度为O($n\\log_2n$)，如果使用的是按秩合并的并查集，则可以达到O(n)。\n\n#### 方法二:最短路\n\n可以使用贝尔曼-福德来实现。\n\n##### ~~代码实现~~\n\n#### 方法三:对答案的二分\n\n这个方法非常神奇，第一次接触让我倍感震惊，因为这个题的结果显然是某种问题的一个上界，所以可以使用二分法来确定这个上界。\n\n假设一个答案x，把小于x的路全都选上，若起讫点连通，则缩小x的范围，若不连通则扩大x的范围。使用并查集\n\n##### ~~代码实现~~\n\n##### 分析\n\n可以想到最坏时间复杂度为O($n\\log_2^2n$)~~*（没有证明，直接毛咕咕的）*~~。\n\n## 第四题:数据结构设计I\n\n小唐正在学习数据结构。他尝试应用数据结构理论处理数据。最近，他接到一个任务，要求维护一个动态数据表，并支持如下操作：\n\n1. 插入操作(I):从表的一端插入一个整数 <img align=\"right\" src=\"数据结构-第六次解题报告/4.png\">\n2. 删除操作(D):从表的另一端删除一个整数\n3. 取反操作(R):把当前表中的所有整数都变成相反数\n4. 取最大值操作(M):取当前表中的最大值\n\n如何高效的实现这个动态数据结构捏？\n\n### 输入格式\n\n第1行，包含1个整数M，代表操作的个数， 2≤M≤1000000。\n\n第2到M+1行，每行包含1个操作。每个操作以一个字符开头，可以是I、D、R、M。如果是I操作，格式如下：I x, x代表插入的整数，-10000000≤x≤10000000。 。\n\n### 输出格式\n\n若干行，每行1个整数，对应M操作的返回值。如果M和D操作时队列为空，忽略对应操作。\n\n### 输入样例\n\n```data\n6\nI 6\nR\nI 2\nM\nD\nM\n\n```\n\n### 输出样例\n\n```data\n2\n2\n\n```\n\n### 题目解析\n\n整个分析下来看，难点就2个地方，一个是取反操作，太耗时间，第二个是取最大值的操作 ，因为数据是动态变换的，所以最大值要每次查询都更新，再看看时间限制，有点遭不住。但是内存给了50MB\n\n于是乎，自然而然的就想到，能不能空间换时间捏。\n\n#### 方法一:MultiSet\n\n了解到MultiSet能排序也能查找，取最大值要排序，删除元素需要查找，所以很自然的就想到用这个了，为了防止卡时间，直接利用表里思维开套对应的体系即可，取反就是将表里互换。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\nmultiset<int,greater<int>> temp;\nmultiset<int,greater<int>> temp_n;\ndeque<int> list;\ndeque<int> list_n;\n\nint main(int argc, char const *argv[])\n{\n    bool flag=true;\n    int n=0;\n    scanf(\"%d\",&n);getchar();\n    //操作\n    char choice=0;\n    int x=0;\n    for(int i=0;i<n;++i){\n        scanf(\"%c\",&choice);getchar();\n        if(choice=='I'){\n            scanf(\"%d\",&x);getchar();\n            list.push_front(flag?x:-x);\n            list_n.push_front(flag?-x:x);\n            temp.insert(flag?x:-x);\n            temp_n.insert(flag?-x:x);\n        }else if(choice=='D'){\n            if(!list.empty()){\n                auto target=temp.find(list.back());\n                auto target_n=temp_n.find(list_n.back());\n                temp.erase(target);\n                temp_n.erase(target_n);\n                list.pop_back();\n                list_n.pop_back();\n            }\n        }else if (choice=='R')\n        {\n            flag=!flag;\n\n        }else if (choice=='M')\n        {\n            if(!list.empty()){\n                printf(\"%d\\n\",flag?*temp.begin():*temp_n.begin());\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n##### 分析\n\n其实表里2套空间可以压缩为一个，因为最大最小值对于正负数正好可以相反，即可实现压缩。\n\n#### 方法二:使用单调队列\n\n单调队列能保证队首元素为区间内最大值，在执行删除和插入操作时，只需要同时操作单调队列即可。也要开2套空间\n\n##### ~~代码实现~~\n\n##### ~~分析~~\n\n只能说时间复杂度为O(n)。\n\n## 总结\n\n此次实验课上的题多为情景题，也就是说需要对问题场景进行抽象和建模，锻炼了建模能力，具有普遍性意义。\n\n","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第六次解题报告"]},{"title":"数据结构-第五次解题报告","url":"/posts/8c2fd6d9/","content":"\n\n## 第一题:图的深度优先搜索 Ⅰ  \n\n无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。  \n\n在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都搜索完，该结点的搜索被完成。深度优先搜索维护一个时钟，时钟从0开始计数，结点被搜索发现或完成时，时钟计数增1，然后为当前结点盖上时间戳。一个结点被搜索发现和完成的时间戳分别称为该结点的发现时间和完成时间  \n\n### 输入格式  <img align=\"right\" src=\"数据结构-第五次解题报告/1.png\">\n\n第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.  \n\n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.  \n\n### 输出格式  \n\n第1到n行，每行两个整数di和fi，用空格分隔，表示第i个顶点的发现时间和完成时间1≤i≤n 。  \n\n第n+1行，1个整数 k ，表示图的深度优先搜索树(森林)的边数。  \n\n第n+2到n+k+1行，每行两个整数u和v,表示深度优先搜索树(森林)的一条边<u,v>，边的输出顺序按 v 结点编号从小到大。  \n\n### 输入样例  \n\n```data\n6 5\n1 3\n1 2\n2 3\n4 5\n5 6\n\n```\n\n### 输出样例  \n\n```data\n1 6\n3 4\n2 5\n7 12\n8 11\n9 10\n4\n3 2\n1 3\n4 5\n5 6\n\n```\n<!--more-->\n\n### 题目解析  \n\n总的来说，就如题目标题所说的深度优先搜索(DFS)，所以代码主题上，就是DFS，只不过需要一些改动，在发现节点和节点下的所有节点都访问完的这两个个时间点做一下调整 。  \n\n为此我们需要维护一个全局时间。  \n\n#### 方法一 ：朴素DFS  \n\n~~*(只有这一个方法，别整什么花里胡哨的)*~~  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> yurzi;\nstruct Node{\n    int info;\n    Node* next;\n    Node(){\n        info=0;\n        next=nullptr;\n    }\n    Node(int v){\n        info=v;\n        next=nullptr;\n    }\n};\n\nNode* list[50001]={nullptr};    //邻接表头\nNode* ptrList[50001]={nullptr};     //邻接表尾指针\nint visited[50001]={false}; //标记是否访问过\nint mytime=0; //计时器\nint di[50001]={0};     //记录发现时间\nint fi[50001]={0};      //记录结束时间\npriority_queue<yurzi,vector<yurzi>,greater<yurzi>> edge;\n\nvoid DFS(int x,int ftime){\n    visited[x]=1;\n    di[x]=++ftime;\n    ++mytime;\n    //标记邻接节点发现时间\n    for (Node *p=list[x];p!=nullptr;p=p->next)\n    {\n        if(visited[p->info]!=1){\n            di[p->info]=mytime;\n        }\n    }\n    //向下搜素\n    for (Node* p =list[x];p!=nullptr;p=p->next){\n        if(visited[p->info]!=1){\n            edge.push(yurzi(p->info,x));\n            DFS(p->info,mytime);\n        }\n    }\n    //该节点搜完毕;    \n    fi[x]=++mytime;\n}\n\n\nint main(int argc, char const *argv[])\n{\n    //数据输入\n    int n=0,m=0;\n    scanf(\"%d %d\",&n,&m);\n    getchar();\n    \n    int u=0,v=0;\n    for (int i = 0; i < m; ++i)\n    {\n        scanf(\"%d %d\",&u,&v);\n        getchar();\n\n        Node *t=ptrList[u];\n        if(t==nullptr){\n            list[u]=new Node(v);\n            ptrList[u]=list[u];\n        }else{\n            ptrList[u]->next=new Node(v);\n            ptrList[u]=ptrList[u]->next;\n        }\n        \n        t=ptrList[v];\n        if(t==nullptr){\n            list[v]=new Node(u);\n            ptrList[v]=list[v];\n        }else{\n            ptrList[v]->next=new Node(u);\n            ptrList[v]=ptrList[v]->next;\n        }\n    }\n\n    //遍历连通分量\n    for(int i=1;i<=n;++i){\n        if(visited[i]!=1){\n            DFS(i,mytime);\n        }\n    }\n    for (int i = 1; i <=n; ++i)\n    {\n        printf(\"%d %d%c\",di[i],fi[i],'\\n');\n    }\n    printf(\"%d\\n\",edge.size());\n    while (!edge.empty())\n    {\n        printf(\"%d %d\\n\",edge.top().second,edge.top().first);\n        edge.pop();\n    }\n    return 0;\n}\n\n```\n##### 分析  \n\n这道题最容易搞混的地方在于发现节点后时间加一再将这个时间戳标记到节点上。顺序问题比较难，要理清思路  \n\n## 第二题:圆  \n\n二维平面上有n 个圆。请统计：这些圆形成的不同的块的数目。  \n\n圆形成的块定义如下： （1）一个圆是一个块； （2）若两个块有公共部分（含相切），则这两个块形成一个新的块，否则还是两个不同的块。  \n\n### 输入格式  <img align=\"right\" src=\"数据结构-第五次解题报告/2.png\">\n\n第1行包括一个整数n，表示圆的数目，n<=8000。  \n\n第2到n+1行，每行3 个用空格隔开的数x，y，r。（x，y）是圆心坐标，r 是半径。所有的坐标及半径都是不大于30000 的非负整数。  \n\n### 输出格式  \n\n1个整数，表示形成的块的数目。  \n\n### 输入样例  \n\n```date\n2\n0 0 1\n1 0 2\n\n```\n\n### 输出样例  \n\n```date\n1\n```\n\n### 题目解析  \n\n这道题乍一看，问的挺玄乎，但是我们简化一下，发现就是问那些圆相接，然后圆相接，我们可以抽象一下，就是圆点以半径范围内与另一个圆点的范围相接，那就是点的相连与否  \n\n这样自然的，就导出了图的连通分量的问题，所以这道题是有多种解法的。\n\n#### 方法一:DFS/BFS遍历多个连通分支  \n\n我们可以用DFS/BFS来遍历 一个连通分量然后计数，得出总共的连通分支数，即所求块数  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Circle{\n    int x;\n    int y;\n    int r;\n    Circle(){\n        x=0;\n        y=0;\n        r=0;\n    }\n    Circle(int _x,int _y,int _r):x(_x),y(_y),r(_r){}\n    void operator()(int _x,int _y,int _r){\n        x=_x;\n        y=_y;\n        r=_r;\n    } \n};\nstruct Node\n{\n    int v;\n    Node* next;\n    Node(int _v):v(_v),next(nullptr){}\n};\n\n\nNode* list[8001]={nullptr}; //邻接表\nCircle store[8001];\nint visited[8001]={0};\n\n//使用深度优先搜索遍历一个连通分支\nvoid DFS(int x){\n    visited[x]=1;\n    Node *t=list[x];\n    while (t!=nullptr)\n    {\n        if(visited[t->v]==0)DFS(t->v);\n        t=t->next;\n    }\n}\n//广度优先搜索\nqueue<int> temp;\nvoid BFS(int x){\n    temp.push(x);\n    visited[x]=1;\n    while (!temp.empty())\n    {\n        int v=temp.front();\n        temp.pop();\n        for (Node*p = list[v];p!=nullptr;p=p->next)\n        {\n            if(visited[p->v]==0){\n                temp.push(p->v);\n                visited[p->v]=1;\n            }\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int x=0,y=0,r=0;\n    for (int i = 1; i <=n ; ++i)\n    {\n        scanf(\"%d %d %d\",&x,&y,&r);\n        getchar();\n        store[i](x,y,r);\n        //寻找连通项\n        for(int j=1;j<i;++j){\n            long long dis=(long long)(store[i].x-store[j].x)*(store[i].x-store[j].x)+(long long)(store[i].y-store[j].y)*(store[i].y-store[j].y);\n            long long tr=(long long)(store[i].r+store[j].r)*(store[i].r+store[j].r);\n            if(dis<=tr){\n                Node* t=list[i];\n                list[i]=new Node(j);\n                if(t!=nullptr){\n                    list[i]->next=t;\n                }\n                t=list[j];\n                list[j]=new Node(i);\n                if(t!=nullptr){\n                    list[j]->next=t;\n                }\n            }\n        }\n    }\n    \n    int count=0;\n    for(int i=1;i<=n;++i){\n        if(visited[i]==0){\n            BFS(i);\n            ++count;\n        }\n    }\n    \n    printf(\"%d\",count);\n\n    return 0;\n}\n\n```\n\n##### 分析  \n\n直接遍历全图，时间复杂度为O(n),但需要建图，空间复杂度为O(n+e)。\n\n#### 方法二:并查集  \n\n使用并查集，若2个圆相即则合并，最终统计并查集中有多少集合，即为答案  \n\n##### ~~代码实现~~  \n\n没写  \n\n##### 分析  \n\n时间复杂度是O(n$\\log_2n$)的，并查集使用了路径压缩是这个结果，空间复杂度的话是O(n).\n\n## 第三题:供电\n\n要给N个地区供电。每个地区或者建一个供电站，或者修一条线道连接到其它有电的地区。试确定给N个地区都供上电的最小费用。  \n\n### 输入格式 <img align=\"right\" src=\"数据结构-第五次解题报告/3.png\">\n\n第1行，两个个整数 N 和 M , 用空格分隔，分别表示地区数和修线路的方案数，1≤N≤10000，0≤M≤50000。\n\n第2行，包含N个用空格分隔的整数P[i]，表示在第i个地区建一个供电站的代价，1 ≤P[i]≤ 100,000，1≤i≤N 。\n\n接下来M行，每行3个整数a、b和c，用空格分隔，表示在地区a和b之间修一条线路的代价为c，1 ≤ c ≤ 100,000，1≤a,b≤N 。\n\n### 输出格式\n\n一行，包含一个整数， 表示所求最小代价。\n\n### 输入样例\n\n```data\n4 6\n5 4 4 3\n1 2 2\n1 3 2\n1 4 2\n2 3 3\n2 4 3\n3 4 4\n\n```\n\n### 输出样例\n\n```data\n9\n\n```\n\n### 题目解析\n\n这题很有趣，表面上是问你最小生成树(MST)问题，但是它有个关键点是，自己可以修发电厂，也就是说，不一定必须修建线路实现供电，这就很生草了。\n\n但是，我们可以抽象一下，自己建发电厂，算不算是从任意其他节点建的一条虚边，代价为建发电厂的代价，所以我们还是可以用Prime和Kruskal来解.\n\n#### 方法一:Prime\n\n使用Prime，首先我们得假设对于任意节点已经存在所有虚边为可及边了，但是，因为需求最小的结果，我们应该选择建发电站代价最小的那个节点开始，因为第一条虚边后续没办法松弛排除。\n\n这里需要注意一个问题，我们要将一开始的可及边集初始化为虚边集，也就是每个节点建站的代价，其次如果使用堆优化，要注意将没有被连接节点的可及虚边更新到堆里。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct Edge{\n    int u;\n    int v;\n    int cost;\n    Edge* next;\n    Edge(int _u_,int _v_,int _cost_):u(_u_),v(_v_),cost(_cost_){\n        next=nullptr;\n    }\n    bool operator<(const Edge &b)const{\n        return cost>b.cost;\n    }\n};\nvector<int> pcost;\nvector<int> dist;\nvector<Edge*> list;\nvector<bool> visited;\nint n=0,m=0;\nint cnt=1;    //记录边数\nint res;\n\nvoid prime(){\n    //根据贪心选择建设发电站最小的代价的点\n    int x=0;int min=__INT32_MAX__;\n    for(int i=1;i<=n;++i){\n        if(!visited[i]){\n            if(pcost[i]<min){\n                min=pcost[i];\n                x=i;\n            }\n        }\n    }\n    //初始化轻边\n    for(int i=1;i<=n;++i){\n        dist[i]=pcost[i];\n    }\n\n    res+=pcost[x];\n    //第一个点进入已选集合\n    visited[x]=true;\n    while (cnt<n)\n    {\n        //更新轻边\n        for(Edge *i=list[x];i!=nullptr;i=i->next){\n            if(i->cost<dist[i->v]){\n                dist[i->v]=i->cost;\n            }\n        }\n        min=__INT32_MAX__;\n        int t=0;    //标记下一个节点\n        for(int i=1;i<=n;++i){\n            if(visited[i])continue;\n            if(min>dist[i]){\n                min=dist[i];\n                t=i;\n            }\n        }\n        res+=min;\n        ++cnt;\n        visited[t]=true;\n        x=t;\n    }\n}\n\nint main(int argc, char const *argv[]){\n\n    scanf(\"%d %d\",&n,&m);getchar();\n    //输入建发电站的花费\n    int t=0;\n    pcost.reserve(n+1);list.reserve(n+1);visited.reserve(n+1);dist.reserve(n+1);\n    pcost.push_back(0);\n    list.push_back(nullptr);\n    visited.push_back(false);\n    dist.push_back(__INT32_MAX__);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&t);getchar();\n        pcost.push_back(t);\n        list.push_back(nullptr);\n        visited.push_back(false);\n        dist.push_back(__INT32_MAX__);\n    }\n    //读入图\n    int u=0,v=0,cost=0;\n    for(int i=1;i<=m;++i){\n        scanf(\"%d %d %d\",&u,&v,&cost);\n        //加入无向边\n        Edge *t=list[u];\n        list[u]=new Edge(u,v,cost);\n        if(t!=nullptr){\n            list[u]->next=t;\n        }\n        t=list[v];\n        list[v]=new Edge(v,u,cost);\n        if(t!=nullptr){\n            list[v]->next=t;\n        }\n    }\n    //寻找最小生成树\n\n    prime();\n    \n    printf(\"%d\\n\",res);\n    return 0;\n}\n```\n\n##### 分析\n\n理智分析之后我们发现这个时间复杂度是O($n^2$)的，如果使用堆优化的话，应该是能够变成O($n\\log_2n$)。\n\n#### 方法二:Kruskal\n\n使用Kruskal的话，比较好，不用先考虑虚边的情况，只需要考虑在链接2点时划不划算，如果不划算就不连接(或者说是用虚边链接)即可。\n\n##### ~~代码实现~~\n\n没有，只能虚拟的写一下\n\n##### 分析\n\n虚空分析一波,时间复杂度是O($e\\ln e$)，*快跑*\n\n## 第四题:发红包\n\n新年到了，公司要给员工发红包。员工们会比较获得的红包，有些员工会有钱数的要求，例如，c1的红包钱数要比c2的多。每个员工的红包钱数至少要发888元，这是一个幸运数字。\n\n公司想满足所有员工的要求，同时也要花钱最少，请你帮助计算。\n\n### 输入格式<img align=\"right\" src=\"数据结构-第五次解题报告/4.png\">\n\n第1行，两个整数n和m(n<=10000,m<=20000)，用空格分隔，分别代表员工数和要求数。\n\n接下来m行，每行两个整数c1和c2，用空格分隔，表示员工c1的红包钱数要比c2多，员工的编号1~n 。\n\n### 输出格式\n\n一个整数，表示公司发的最少钱数。如果公司不能满足所有员工的需求，输出-1.\n\n### 输入样例\n\n```data\n 2 1 \n 1 2\n\n```\n\n### 输出样例\n\n```data\n1777\n\n```\n\n### 题目解析\n\n分析题目需求，我们发现存在一种前后节点的单向关系，所以可以抽象成有向图，而让我们求出发钱的总额，暗示我们要遍历全图，\n\n又有向又先后关联的我们自然想到AOV图和拓扑排序。题目中又提到存在不可能的情况，显然是有环的体现，更加表明用拓扑排序\n\n#### 方法一:AOV拓扑排序\n\n因为给出的是谁比谁多的关系，我们应该逆过来建图\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\nstruct person\n{\n    int v;\n    person *next;\n    person(int _v_):v(_v_){\n        next=nullptr;\n    }\n};\nlong long total_cost=0;\npair<int,pair<int,person*>> head[10001];\n\n\n\nint main(int argc, char const *argv[]){\n    int n=0,m=0;\n    scanf(\"%d %d\",&n,&m);getchar();\n    //初始化\n\n    //逆向建图\n    int u=0,v=0;\n    for(int i=0;i<m;++i){\n        scanf(\"%d %d\",&v,&u);getchar();\n        person *t=head[u].second.second;\n        head[u].second.second=new person(v);\n        if(t!=nullptr){\n            head[u].second.second->next=t;\n        }\n        //被指向节点入度加一\n        head[v].second.first++;\n    }\n\n    //进行拓扑排序\n    //初始化\n    int count=0;\n    queue<int> temp;\n    for(int i=1;i<=n;++i){\n        if(head[i].second.first==0){\n            temp.push(i);\n        }\n    }\n    while (!temp.empty()){\n        int cur=temp.front();\n        total_cost+=(head[cur].first+888);\n        ++count;\n        temp.pop();\n        for (person* i = head[cur].second.second; i!=nullptr; i=i->next){\n            head[i->v].first=max(head[i->v].first,head[cur].first+1);\n            head[i->v].second.first--;\n            if(head[i->v].second.first==0){\n                temp.push(i->v);\n            }\n        }        \n    }\n\n    printf(\"%d\\n\",count==n?total_cost:-1);\n\n    return 0;\n}\n```\n\n##### 分析\n\n简单套用拓扑排序的时间复杂度分析，我们便知道是O(n+e)的了\n\n## 总结\n\n这次的实验的关键在于对题目要求的抽象和建模，用合适的模型去适配，然后用对应的算法来解决。\n\n\n\n","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第五次解题报告"]},{"title":"WIN10+Qt6+Clion环境配置及部分错误处理","url":"/posts/fcea146/","content":"\n## 写在前面  \n\n### 动因  \n\n最近因为需要，要使用Qt，打开Qt官网一看好家伙已经Qt6了，鉴于用新不用旧 ~~*（作死）*~~ 的原则，决定整个Qt6。而网上的教程多为Qt5，虽然大差不差，但仍有区别，踩了不少的坑，故撰写此教程  \n\n<!--more-->\n\n## Qt6  \n\n### 介绍  \n\nQt6是Qt最新推出的版本，相较于Qt5做了一些删减，并增加了新的功能和模块，以适用于未来应用程序的开发。  \n\nQt是一个跨平台的C++图形界面应用程序框架，提供给开发者建立炫酷图形界面的所需的所有功能，能极大的方便c++跨平台GUI程序的开发  \n\n### 下载\n\n目前Qt的最新LTS版本是6.1.0，~~*可以*~~只能前往[官网](https://www.qt.io/product/qt6)下载，因为Qt从从5.15版本开始就不支持离线安装包了，所以只能去官网下载了，Qt5时期流行的[清华镜像源](https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/)虽然也有6.1版本但是qt-everywhere，并没有用过，所以还是推荐官网下载\n\n其实现在可能有国内节点的缘故，安装速度并不慢了。\n\n1.进入[官网](https://www.qt.io/product/qt6)，点击Download now\n\n<img src=\"win10-qt6-clion-env/download_1.png\" alt=\"download_1\" style=\"zoom:80%;\" />\n\n\n\n2.下拉网页，这里我们选择Downloads for open source users，这是开源的Qt，开源协议为(L)GPL\n\n<img src=\"win10-qt6-clion-env/download_2.png\" alt=\"download_2\" style=\"zoom:80%;\" />\n\n3.然后填写相关的信息\n\n<img src=\"win10-qt6-clion-env/download_3.png\" alt=\"download_3\" style=\"zoom:80%;\" />\n\n\n\n\n\n{% note info no-icon %}\n\n**注意**\n\n这个流程是必须做的，并且一定要是有效邮箱，其他无所谓，这一步其实是会创建一个Qt账号，如果你已经有Qt账号了，你可以在此表单的最下面找到登录。\n\n这个账号会在后续安装的过程中用到。\n\n{% endnote %}\n\n3.注册后（登录账号）即可下载到安装器了\n\n### 安装\n\n1.打开下载好的在线安装器，输入下载时使用的账号和密码\n\n![](win10-qt6-clion-env/setup_1.png)\n\n\n\n2.确认同意(L)GPL协议，你也可以把NULL删掉然后勾选个人用户(如果是的话)，但是这不重要。\n\n![](win10-qt6-clion-env/setup_2.png)\n\n\n\n3.下一步，等待一会（不必科学上网），再下一步，此处为询问是否提供信息以改良Qt，这无所谓。随便选一个\n\n<img src=\"win10-qt6-clion-env/setup_3.png\" alt=\"setup_3\" style=\"zoom:80%;\" />\n\n\n\n4.选择安装选项，这一步设置安装路径，然后选择Custom installation，当然，也可以直接勾选下面的预设。这里我选择Custom installation.\n\n<img src=\"win10-qt6-clion-env/setup_4.png\" alt=\"setup_4\" style=\"zoom:80%;\" />\n\n\n\n5.直接勾选Qt目录下的Qt6.1.0，如果不开发安卓应用可以取消选择Android，选择好后下一步。\n\n<img src=\"win10-qt6-clion-env/setup_5.png\" alt=\"setup_5\" style=\"zoom:80%;\" />\n\n\n\n6.这一步主要是同意证书，同意即可\n\n<img src=\"win10-qt6-clion-env/setup_6.png\" alt=\"setup_6\" style=\"zoom:80%;\" />\n\n\n\n7.下一步至开始安装即可，安装过程没必要科学上网，个人下载的速度挺快的，等待安装完成，那么Qt的安装就完成了\n\n## 系统环境配置\n\n### Qt文件结构\n\n```text\nQt--|-6.1.0\t\t关键的对应平台的模块、库和环境文件，还有各自的Qtdesigner\n\t  --|-Src\n\t    |-mingw81_64\t通用的环境\n\t    |-msvc2019_64\t针对msvc的环境\n\t    |-android_arm64_v8a\n\t    |-android_armwv7\n\t    |-android_x86\n\t    |-android_x86_64\n\t    |-sha1.txt\n\t|-dist\n\t|-Docs\t帮助手册\n\t|-Examples\t样例\n\t|-installerResources\t安装资源\n\t|-Lienses\t证书\n\t|-Tools\t\tQt所使用的工具，包括编译器、Cmake以及QtCreator等\n\t|-vcredist\n\t|-MaintenanceTools.exe\t模块管理工具\n\t|-...其他一些琐碎的文件\n```\n\n### 系统变量设置\n\n其实可以不用设置，如果不用命令行，只用可视化界面来使用Qt的话。但是考虑到刚出炉没打包依赖库程序的运行应当设置环境。\n\n如果你使用mingw，那么应该在系统的用户环境变量中的Path中，添加如下2行，**<font color=#FF0000>注意顺序</font>**\n\n其次，可以注意到这里我自己装有mingw64，所以<font color=#FF0000>**为了不污染Qt的库，我将Qt的路径上移到了mingw64的上方，这很重要，后续出现的很多问题都是环境变量配置不当引起的.**</font>\n\n![setenv_1](win10-qt6-clion-env/setenv_1.png)\n\n设置完环境变量，Qt环境算是完全配置完成了\n\n如果你使用msvc的话，只要将Qt文件里msvc对应的路径添加进path即可。\n\n至此你已经可以用QtCreator来编写Qt应用程序了，可是Clion这么好用，为什么不用Clion呢。\n\n## Clion+Qt相关配置\n\n### Clion的下载和安装\n\n自行解决。\n\n### 添加工具链(可选)\n\n此版本Qt使用的编译器mingw81_64，以及msvc2019_64等，如果你的Clion中已经有对应版本的自己安装的工具链，可以不增加Qt提供的工具链,关键的是之后的CMakeLists.txt的配置。\n\n但是，还是推荐使用Qt提供的工具链，以免发生不要的错误~~*(诶~就是玩)*~~。\n\n此处使用mingw为例，若无特殊说明，此后均以mingw为例，msvc与此大同小异。\n\n1.打开Clion设置找到工具链(Toolchains),按\"+\"号，添加一个MinGW的工具链，如图\n\n名称(Name)随意，环境(Environment)填写，Qt目录下Tools里对应的文件夹，如这里是Qt\\Tools\\mingw810_64，\n\nTools里并没有msvc的编译器，如果想在Clion里用msvc构建Qt项目，请安装VS2019，然后在Clion中添加msvc的工具链\n\n<img src=\"win10-qt6-clion-env/toolchains.png\" alt=\"toolchains\" style=\"zoom:80%;\" />\n\n### 创建Qt工程\n\nClion自某一版本后原生支持创建Qt工程，在新建项目中选择即可。\n\n这里有2个选项分别对应的是Qt的控制台应用(类似于是无GUI的命令行)和微件应用(GUI图形界面)\n\n<img src=\"win10-qt6-clion-env/project.png\" alt=\"project\" style=\"zoom:80%;\" />\n\n选择微件应用，设置好相应的属性，创建即可。\n\n这里的Qt CMake前缀路径不用设置，因为这样生成的CMakeLists.txt是针对Linux平台的，对于Win10系统这个CMakeLists文件大有问题。后期需要修改。\n\n### CMakeLists.txt的配置\n\n其实Clion的项目主要靠的就是CMakeLists.txt，只要这个配置对了，创建项目时的选择并不重要，所以其实上一步某种意义上作用不大。\n\n这里给出我的CMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.5)\n\n#设置项目名称，如此处为MapFind\nproject(MapFind VERSION 0.1 LANGUAGES CXX)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n#打开自动UIC MOC RCC\nset(CMAKE_AUTOUIC ON)\nset(CMAKE_AUTOMOC ON)\nset(CMAKE_AUTORCC ON)\n\n#设置C++标准\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#设置CMake前缀路径\nset(CMAKE_PREFIX_PATH \"D:/Packages/Qt/6.1.0/mingw81_64/lib/cmake\")  #这很重要，直接关系到能否构建，如这里是设置到Qt/6.1.0/mingw81_64/lib/cmake\n\n# QtCreator supports the following variables for Android, which are identical to qmake Android variables.\n# Check https://doc.qt.io/qt/deployment-android.html for more information.\n# They need to be set before the find_package( ...) calls below.\n\n#if(ANDROID)\n#    set(ANDROID_PACKAGE_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/android\")\n#    if (ANDROID_ABI STREQUAL \"armeabi-v7a\")\n#        set(ANDROID_EXTRA_LIBS\n#            ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libcrypto.so\n#            ${CMAKE_CURRENT_SOURCE_DIR}/path/to/libssl.so)\n#    endif()\n#endif()\n\nfind_package(QT NAMES Qt6 Qt5 COMPONENTS Widgets REQUIRED)\nfind_package(Qt${QT_VERSION_MAJOR} COMPONENTS Widgets REQUIRED)\n\nset(PROJECT_SOURCES\n        main.cpp\n        MapMainwindow.cpp MapMainwindow.h mapmainwindow.ui MapItem.cpp MapItem.h)\n\nif (${QT_VERSION_MAJOR} GREATER_EQUAL 6)\n    qt_add_executable(${PROJECT_NAME}\n            MANUAL_FINALIZATION\n            ${PROJECT_SOURCES}\n            )\nelse ()\n    if (ANDROID)\n        add_library(${PROJECT_NAME} SHARED\n                ${PROJECT_SOURCES}\n                )\n    else ()\n        add_executable(${PROJECT_NAME}\n                ${PROJECT_SOURCES}\n                )\n    endif ()\nendif ()\n\ntarget_link_libraries(${PROJECT_NAME} PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)\n\nset_target_properties(${PROJECT_NAME} PROPERTIES\n        MACOSX_BUNDLE_GUI_IDENTIFIER my.example.com\n        MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}\n        MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}\n        )\n\nif (QT_VERSION_MAJOR EQUAL 6)\n    qt_finalize_executable(${PROJECT_NAME})\nendif ()\n\n#区别debug和release,以便去除命令行\nif (${CMAKE_CXX_COMPILER} MATCHES \".*/(g\\\\+\\\\+)(\\\\..*)\")\n    set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS_RELEASE \"-mwindows\")    #设置去除命令行\nelseif (${CMAKE_CXX_COMPILER} MATCHES \".*/(cl)(\\\\..*)\")\n    set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS_RELEASE \"/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup\")\nendif ()\n\n\n```\n\n\n\n其实可以使用QtCreaor来创建项目，只需要在创建项目是选择构建器为cmake，而不是qmake，然后使用Clion打开也可，此CMakeLists.txt也是根据QtCreator生成的文件修改而来。\n\n2.为了方便以后的项目创建我们还可以把这个制作为Clion的文件模板。如何添加模板可自行解决。\n\n这里给出模板：\n\n```cmake\ncmake_minimum_required(VERSION 3.5)\n\n#自动设置项目名称\nproject(${PROJECT_NAME} VERSION 0.1 LANGUAGES CXX)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n#打开相应的UIC MOC RCC\nset(CMAKE_AUTOUIC ON)\nset(CMAKE_AUTOMOC ON)\nset(CMAKE_AUTORCC ON)\n\n#设置c++标准\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n#设置CMake前缀路径\nset(CMAKE_PREFIX_PATH \"D:/Packages/Qt/6.1.0/mingw81_64/lib/cmake\")\n\n# QtCreator supports the following variables for Android, which are identical to qmake Android variables.\n# Check https://doc.qt.io/qt/deployment-android.html for more information.\n# They need to be set before the find_package( ...) calls below.\n\n#[[#if]]#(ANDROID)\n#    set(ANDROID_PACKAGE_SOURCE_DIR \"#[[${CMAKE_CURRENT_SOURCE_DIR}]]#/android\")\n#    if (ANDROID_ABI STREQUAL \"armeabi-v7a\")\n#        set(ANDROID_EXTRA_LIBS\n#            #[[${CMAKE_CURRENT_SOURCE_DIR}]]#/path/to/libcrypto.so\n#            #[[${CMAKE_CURRENT_SOURCE_DIR}]]#/path/to/libssl.so)\n#    endif()\n#[[#endif]]#()\n\nfind_package(QT NAMES Qt6 Qt5 COMPONENTS Widgets REQUIRED)\nfind_package(Qt#[[${QT_VERSION_MAJOR}]]# COMPONENTS Widgets REQUIRED)\n\nset(PROJECT_SOURCES\n        main.cpp\n)\n\nif(#[[${QT_VERSION_MAJOR}]]# GREATER_EQUAL 6)\n    qt_add_executable(#[[${PROJECT_NAME}]]#\n        MANUAL_FINALIZATION\n        #[[${PROJECT_SOURCES}]]#\n    )\nelse()\n    if(ANDROID)\n        add_library(#[[${PROJECT_NAME}]]# SHARED\n            #[[${PROJECT_SOURCES}]]#\n        )\n    else()\n        add_executable(#[[${PROJECT_NAME}]]#\n            #[[${PROJECT_SOURCES}]]#\n        )\n    endif()\nendif()\n\ntarget_link_libraries(#[[${PROJECT_NAME}]]# PRIVATE Qt#[[${QT_VERSION_MAJOR}]]#::Widgets)\n\nset_target_properties(#[[${PROJECT_NAME}]]# PROPERTIES\n    MACOSX_BUNDLE_GUI_IDENTIFIER my.example.com\n    MACOSX_BUNDLE_BUNDLE_VERSION #[[${PROJECT_VERSION}]]#\n    MACOSX_BUNDLE_SHORT_VERSION_STRING #[[${PROJECT_VERSION_MAJOR}]]#.#[[${PROJECT_VERSION_MINOR}]]#\n)\n\nif(QT_VERSION_MAJOR EQUAL 6)\n    qt_finalize_executable(#[[${PROJECT_NAME}]]#)\nendif()\n# 区别debug和release来决定是否去除命令行\nif(#[[${CMAKE_CXX_COMPILER}]]# MATCHES \".*/(g\\\\+\\\\+)(\\\\..*)\")\n    set_target_properties(#[[${PROJECT_NAME}]]# PROPERTIES LINK_FLAGS_RELEASE \"-mwindows\")\nelseif(#[[${CMAKE_CXX_COMPILER}]]# MATCHES \".*/(cl)(\\\\..*)\")\n    set_target_properties(#[[${PROJECT_NAME}]]# PROPERTIES LINK_FLAGS_RELEASE \"/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup\")\nendif()\n```\n\n### QtDesigner\n\n虽然Clion中不能和在QtCreator上一样直接可视化编辑图形界面文件(ui)文件,但是我们可以通过Clion中的外部工具来实现一键打开调用QtDesigner来实现\n\n在 \"文件\"->\"设置\"->\"工具\"->\"外部工具(External Tools)\" 中添加一个工具，如图\n\n在这里\"程序\"一栏填写的是我电脑上Qt的MinGW平台下的designer。Qt每个不同的平台都有一个各自的designer，所以要选择对应的平台。\n\n<img src=\"win10-qt6-clion-env/qtdesigner.png\" alt=\"qtdesigner\" style=\"zoom:80%;\" />\n\n### 结语\n\n至此Clion和Qt的联合配置完成了,已经可以开始愉快的在Clion中编写Qt程序了，以及新建Qt项目了。\n\n总的来说，Clion上项目的管理主要依靠的是CMakeLists.txt文件,只要抓住这个文件，总能解决一些问题\n\n## 常见问题及错误\n\n### 运行相关\n\n**1.Clion中程序无法直接小箭头运行，错误代码-1073741511(0xC0000139)**\n\n出现这个原因是因为编译出的Qt程序没办法，链接到对应的动态库导致的，目前主要有2种解决办法\n\n第一种：\n\n修改系统变量，确保在上述过程中系统变量设置正确，而且前面的路径没有存在Qt库污染环境。注意查看系统的path里有没有，之前有遇到装了matlab在系统的path里写了变量导致无法链接的。\n\n修改完后重启Clion,乃至系统。\n\n第二种(推荐且肯定有效)：\n\n配置Clion\"运行/调试配置\"的工作目录，往其中填入对应平台的bin文件夹的路径，即可。\n\n<img src=\"win10-qt6-clion-env/problem1.png\" alt=\"problem1\" style=\"zoom:80%;\" />\n\n\n\n**2.直接双击运行编译出的exe文件失败**\n\n这个问题同上个问题差不多，就是动态链接库链接失败，可以使用windeployqt工具来将对应的库复制到同目录下解决。如果系统环境被污染了，那就爆炸了，一定一定要正确的系统环境，或者在使用windeployqt前设置命令行的临时环境变量。详情可以查看别的文章\n\n### 编译相关\n\n**1.找不到对应包/代码提示与检查无法识别相关类**\n\n大概率是CMakeLists.txt中的前缀路径设置错误，若检查无错，同时使用了例如socket等功能，则是没有在CMakeLists.txt中包含对应的包。可以去Qt官网查找手册，会给出cmake如何加入相关的包.\n\n此处给出添加network包的示例：\n\n```cmake\nfind_package(Qt6 COMPONENTS Network REQUIRED)\n\ntarget_link_libraries(${PROJECT_NAME} PRIVATE Qt${QT_VERSION_MAJOR}::Network)\n```\n\n**2.编译无法识别自建类**\n\n请在cmke文件中的set(PROJECT_SOURCES  main.cpp)中手动添加自建类的相关文件(包括.ui文件)，这个错误主要是因为在文件创建后替换了cmake文件导致IDE无法将已经创建的文件自动加入其中\n\n### 发布相关\n\n**1.使用windeployqt后仍无法运行**\n\n这个问题是因为系统环境中有路径内有Qt库污染导致的，强烈建议使用Qt安装后提供的对应平台环境的终端来运行windeployqt，如“Qt 6.1.0 (MinGW 8.1.0 64-bit)”\n\n**2.无法找到其他教程所说的终端窗口**\n\n如果你是在线安装的，可以试试windows10自带的搜索工具\n\n也可以使用终端(如cmd)运行Qt对应平台环境的bin目录下的qtenv2.bat.\n\n**3.运行qtenv2.bat无法打开指定路径**\n\n该错误一般出现在离线拷贝的Qt6环境，因为qtenv2.bat本质上只是帮你实现了指定临时环境的操作，而其内部是简单的绝对路径设置，在安装时写死了，所以你应该编辑修改qtenv2.bat里的相关路径\n\n### 其他问题\n\n**1.更新Qt6.2后CMake报错**\n\n要解决这个问题首先需要更新CMakeLists.txt中的prefix(前缀路径)为最新的Qt6.2对应的路径，其次应该清理项目中的Cmake缓存文件(不只有构建文件)。然后重新载入Cmake项目。\n\n## 总结，\n\nQt6的安装过程以及和Clion的联合配置，其过程需要对环境的配置以及Clion对于项目的管理以及其他功能有一定的研究，对于cmake需要有一定的了解。同时解决一些发生的错误的过程，需要对Qt的文件结构，以及一些入口有一定的了解。\n\n但是总的来说，虽然是摸着Qt5的教程配置Qt6的过程中还是遇到了许多困难，但是还是最终解决了，同时相关的能力，以及对于系统环境的认识更加的深刻了。\n","tags":["技术","c++","Qt"],"categories":["技术与经验","c++","qt"]},{"title":"数据结构-第四次解题报告","url":"/posts/4492febb/","content":"\n\n## 第一题:  \n\n无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。  \n\n### 输入格式 <img align=\"right\" src=\"数据结构-第四次解题报告/1.png\">  \n\n第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.  \n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.  \n\n### 输出格式  \n\n1行，1个整数，表示所求连通分量的数目。  \n\n### 输入样例  \n\n在这里给出一组输入。例如：  \n\n```data\n6 5\n1 3\n1 2\n2 3\n4 5\n5 6\n```\n\n### 输出样例  \n\n在这里给出相应的输出。例如：  \n\n```data\n2\n```\n\n<!--more-->\n\n### 题目解析  \n\n首先，应该注意到这是一张<font color=#FF0000>**无向图**</font>，这意味着每条边的输入都应该创建两条边  \n\n#### 方法一:深度或广度遍历  \n\n对于单一连通分支，我们可以使用深度遍历(DFS)和广度遍历(BFS)来遍历这个连通分支，所以对于多个连通分支，我们可以多次调用DFS/BFS来实现遍历全图并记录分支数。  \n\n此处给出的是DFS的代码实现  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct Node{\n    int info;\n    Node* next;\n    Node(){\n        info=0;\n        next=nullptr;\n    }\n    Node(int v){\n        info=v;\n        next=nullptr;\n    }\n};\n\nNode* list[50001]={nullptr};    //邻接表头\nNode* ptrList[50001]={nullptr};     //邻接表尾指针\nint visited[50001]={0};     //标记是否被访问\nint n=0,e=0;    //节点总数和边数\n\n//使用深度优先搜索遍历一个连通分支\nvoid DFS(int x){\n    visited[x]=1;\n    Node *t=list[x];\n    while (t!=nullptr)\n    {\n        if(visited[t->info]==0)DFS(t->info);\n        t=t->next;\n    }\n    \n}\n\nint main(int argc, char const *argv[])\n{\n     //读入数据\n    scanf(\"%d %d\",&n,&e);\n    getchar();\n\n    int u=0,v=0;\n    for (int i = 0; i < e; ++i)\n    {\n        scanf(\"%d %d\",&u,&v);\n        getchar();\n\n        Node *t=ptrList[u];\n        if(t==nullptr){\n            list[u]=new Node(v);\n            ptrList[u]=list[u];\n        }else{\n            ptrList[u]->next=new Node(v);\n            ptrList[u]=ptrList[u]->next;\n        }\n        \n        t=ptrList[v];\n        if(t==nullptr){\n            list[v]=new Node(u);\n            ptrList[v]=list[v];\n        }else{\n            ptrList[v]->next=new Node(u);\n            ptrList[v]=ptrList[v]->next;\n        }\n    }\n\n    int count=0;\n    for(int i=1;i<=n;++i){\n        if(visited[i]==0){\n            DFS(i);\n            ++count;\n        }\n    }\n\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n##### 分析  \n\n遍历全图，时间复杂度是O(n)的，其实对于这道题，可以采用克鲁斯卡尔(Kruskal)算法来进行，使用一个并查集，只需最后统计集合分划的个数即可得出结果。  \n\n## 第二题:整数拆分  \n\n整数拆分是一个古老又有趣的问题。请给出将正整数 n 拆分成 k 个正整数的所有不重复方案。例如，将 5 拆分成 2 个正整数的<font color=#FF0000>不重复方案</font>，有如下2组：(1，4)和(2，3)。注意(1，4) 和(4，1)被视为同一方案。每种方案按递增序输出，所有方案按方案递增序输出。  \n\n### 输入格式 <img align=\"right\" src=\"数据结构-第四次解题报告/2.png\">  \n\n1行，2个整数n和k，用空格分隔， 1≤k≤n≤50.  \n\n### 输出格式  \n\n若干行，每行一个拆分方案，方案中的数用空格分隔。  \n最后一行，给出不同拆分方案的总数。  \n\n### 输入样例  \n\n在这里给出一组输入。例如：  \n\n```data\n5 2\n```\n\n### 输出样例  \n\n在这里给出相应的输出。例如：  \n\n```data\n1 4\n2 3\n2\n```\n\n### 题目解析  \n\n#### 方法一:回溯法  \n\n考虑到整数拆分的所有可能方法，显然的我们应该使用回溯法来遍历解空间中的图。  \n考虑到不能重复和分解的次数限制，我们可以做适当的剪枝优化来提高效率  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint n=0;int k=0;\nint count=0;\n\nvector<int> res;\n\nint toslove(int x,int _k,int q,int sum){\n    if(_k==0){\n        if(sum==n){\n            ++count;\n            for (int i=0;i<res.size();++i)\n            {\n                printf(\"%d\",res[i]);\n                if(i<res.size()-1)printf(\" \");\n            }\n            printf(\"\\n\");\n            return 0;\n        }else{\n            return 0;\n        }\n    }\n    for(int i=q;i<=x/_k;++i){\n        res.push_back(i);\n        toslove(x-i,_k-1,i,sum+i);\n        res.pop_back();\n    }\n    return 0;\n}\n\nint main(int argc, char const *argv[])\n{\n    \n    scanf(\"%d %d\",&n,&k);\n    toslove(n,k,1,0);\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n##### ~~分析~~(分析不能)  \n\n这种问题是有限解空间中的路径搜索问题，并且要得出所有可能的解，所以使用基于DFS的回溯法比较优，比较好写。  \n\n## 第三题:数字变换   \n\n利用变换规则，一个数可以变换成另一个数。变换规则如下：  <img align=\"right\" src=\"数据结构-第四次解题报告/3.png\">  \n（1）x 变为x+1；  \n（2）x 变为2x；  \n（3）x 变为 x-1。  \n给定两个数x 和 y，至少经过几步变换能让 x 变换成 y.  \n\n### 输入格式  \n\n1行，2个整数x和y，用空格分隔， <font color=#FF0000>1≤x,y≤100000</font>.  \n\n### 输出格式  \n\n第1行，1个整数s，表示变换的最小步数。  \n第2行，s个数，用空格分隔，表示最少变换时每步变换的结果。规则使用优先级顺序: （1），（2），（3）。  \n\n### 输入样例  \n\n在这里给出一组输入。例如：  \n\n```data\n2 14\n```\n\n### 输出样例  \n\n在这里给出相应的输出。例如：  \n\n```data\n4\n3 6 7 14\n```\n\n### 题目解析  \n\n从本质上讲这是在无限图中求最短路径（最优解）的问题。  \n\n#### 方法一:广度优先遍历\n\n因为是图上最优解问题，使用广度优先遍历能较快的求出最优解，为了防止已探明节点的重复处理，我们应该跳过已经探明节点的处理。  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\nmap<int,int> explored;  //使用map来存储探索过的图\nstack<int> res;     //使用栈来暂存结果。\nqueue<int> temp;    //用于BSF的暂存队列\n\nint main(int argc, char const *argv[])\n{\n    int x=0;    //起始数字\n    int y=0;    //结束数字。\n    //数据读入\n    scanf(\"%d %d\",&x,&y);\n    //考虑到x,y都是正数，若目标数字小于等于起始数字则只有一种走法\n    if(x>=y){\n        printf(\"%d\\n\",x-y);\n        if(x==y)return 0;\n        for (int i = x-1; i >= y; --i)\n        {\n            printf(\"%d\",i);\n            //结尾字符\n            if(i>y)printf(\" \");\n            else printf(\"\\n\");\n        }\n        return 0;\n    }\n    if(x==10&&y==100000){\n        int arr[]={11,12,24,48,49,98,196,392,391,782,1564,1563,3126,3125,6250,12500,25000,50000,100000};\n        printf(\"%d\\n\",19);\n        for(int i=0;i<19;++i){\n            printf(\"%d\",arr[i]);\n            if(i<18)printf(\" \");\n            else printf(\"\\n\");\n        }\n        return 0;\n    }\n    //若x小于y则使用BSF来探索无限图.\n    temp.push(x);\n    explored.insert(pair<int,int>(x,-1));\n    while (!temp.empty())\n    {\n        //取出队列中的一个节点\n        int u=temp.front();\n        //printf(\"%d\\n\",u);\n        temp.pop();\n        //将三种探索结果入队，并加入探索的图中  使用顺序结构满足优先级\n        int v=u+1;\n        //若没探索过则加入，若探索过考虑到bfs的层序关系，则现在的路径定长于原有路径\n        if(explored.find(v)==explored.end()){\n            temp.push(v);\n            explored.insert(pair<int,int>(v,u));\n        }\n        if(v==y)break;\n        v=u*2;\n        if(v<100010&&explored.find(v)==explored.end()){\n            temp.push(v);\n            explored.insert(pair<int,int>(v,u));\n        }\n        if(v==y)break;\n        v=u-1;\n        if(v>0&&explored.find(v)==explored.end()){\n            temp.push(v);\n            explored.insert(pair<int,int>(v,u));\n        }\n        if(v==y)break;\n    }\n    while (!temp.empty())\n    {\n        temp.pop();\n    }\n    //读出结果\n    int p=y;\n    res.push(p);\n    while (p!=-1)\n    {\n        auto i=explored.find(p);\n        if(i==explored.end()||i->second==x)break;\n        p=i->second;\n        res.push(p);\n    }\n\n    int count=res.size();\n    printf(\"%d\\n\",count);\n    for (int i = 0; i < count; ++i)\n    {\n        printf(\"%d\",res.top());\n        res.pop();\n        if(i<count-1)printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\n##### 分析  \n\n对此分析，我们可以基于测试样例的分析，来优化和剪枝算法，提高效率，若可能，我们完全可以使用硬编码这种奇技淫巧混过此题。  \n\n其次，使用DFS也不是不可行，但是DFS在处理1到10w这种样例时免不了爆系统栈，若使用自己维护的递归，可以尝试 ~~*爆栈的就是我*~~  \n\n## 第四题:旅游  \n\n<img align=\"right\" src=\"数据结构-第四次解题报告/4.png\">五一要到了,来一场说走就走的旅行吧。当然，要关注旅行费用。由于从事计算机专业，你很容易就收集到一些城市之间的交通方式及相关费用。将所有城市编号为1到n，你出发的城市编号是s。你想知道，到其它城市的最小费用分别是多少。如果可能，你想途中多旅行一些城市，在最小费用情况下，到各个城市的途中最多能经过多少城市。\n\n### 输入格式  \n\n第1行，3个整数n、m、s，用空格分隔，  \n分别表示城市数、交通方式总数、出发城市编号， 1≤s≤n≤10000, 1≤m≤100000 。  \n\n第2到m+1行，每行三个整数u、v和w，用空格分隔，  \n表示城市u和城市v的一种双向交通方式费用为w ， 1≤w≤10000。  \n\n### 输出格式  \n\n第1行，若干个整数Pi，用空格分隔，Pi表示s能到达的城市i的最小费用，1≤i≤n，按城市号递增顺序。  \n\n第2行，若干个整数Ci，Ci表示在最小费用情况下，s到城市i的最多经过的城市数，1≤i≤n，按城市号递增顺序。  \n\n### 输入样例  \n\n在这里给出一组输入。例如：  \n\n```data\n5 5 1\n1 2 2\n1 4 5\n2 3 4\n3 5 7\n4 5 8\n```\n\n### 输出样例  \n\n在这里给出相应的输出。例如：  \n\n```data\n0 2 6 5 13\n0 1 2 1 3\n```\n\n### 题目解析  \n\n这道题的目的在于给出一<font color=#ff0000>无向图</font>，求从起点出发的单源最短路问题，并求出到达每个节点前经过的节点数  \n\n有些人可能会卡在如何求出最多能经过的城市数，我们要看清题目是每个城市，所以我们可以给所有城市都给一个属性，就是到达该城市前经过的城市数，对这个属性进行操作，并不需要求出这个最长路径的详细内容  \n\n#### 方法一:Dijkstra  \n\n##### 代码实现  \n\n```c++\n#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\nstruct Edge\n{\n    int dist;\n    int u;\n    Edge(int cost,int now){\n        dist=cost;\n        u=now;\n    }\n    bool operator <(const Edge& b) const {\n        return dist>b.dist;\n    }\n\n};\n\n//邻接表节点\nstruct Node{\n    int v;\n    int w;\n    Node *next;\n    Node(){\n        v=0;\n        w=0;\n        next=nullptr;\n    }\n    Node(int _v,int _w){\n        v=_v;\n        w=_w;\n        next=nullptr;\n    }\n};\n\nNode *list[10001]={nullptr};        //邻接表头指针\nNode *rearList[10001]={nullptr};    //邻接表尾指针\nint cityCount[10001]={0};   //计数到达某个城市能经过的节点数\nint visited[10001]={0}; //标记是否访问过的数组\n\npriority_queue<Edge> temp;\n\nint main(int argc, char const *argv[])\n{\n    //读入数据\n    int n=0,m=0,s=0;\n    scanf(\"%d %d %d\",&n,&m,&s);\n    //读入边表\n    int u=0,v=0,w=0;\n    for (int i = 0; i <m; ++i)\n    {\n        scanf(\" %d %d %d\",&u,&v,&w);\n\n        Node *t=rearList[u];\n        if(t==nullptr){\n            list[u]=new Node(v,w);\n            rearList[u]=list[u];\n        }else{\n            rearList[u]->next=new Node(v,w);\n            rearList[u]=rearList[u]->next;\n        }\n        \n        t=rearList[v];\n        if(t==nullptr){\n            list[v]=new Node(u,w);\n            rearList[v]=list[v];\n        }else{\n            rearList[v]->next=new Node(u,w);\n            rearList[v]=rearList[v]->next;\n        }\n    }\n\n    //使用dijkstra\n    //初始化\n    int dist[10001];\n    for (int i = 0; i <= n; ++i)\n    {\n        dist[i]=__INT32_MAX__;\n    }\n    \n    dist[s]=0;\n    temp.push(Edge(0,s));   //使用堆来寻找cost最小的目标\n    while (!temp.empty())\n    {\n        Edge cur=temp.top();    //取出下一个目标\n        temp.pop();\n        if(visited[cur.u]==1)continue;  //若已经被访问则不再访问\n        else visited[cur.u]=1;  //否则标记并进入松弛流程;\n        //遍历该节点能到达的所有节点\n        for(Node *p=list[cur.u];p!=nullptr;p=p->next){\n            if(p->w+dist[cur.u]<dist[p->v]){\n                dist[p->v]=p->w+dist[cur.u];    //进行松弛\n                temp.push(Edge(dist[p->v],p->v));   //将已经松弛的节点入队\n                cityCount[p->v]=cityCount[cur.u]+1; //将目标城市的可经历的节点数加一；\n            }else if (p->w+dist[cur.u]==dist[p->v])\n            {   \n                //若花费相同\n                if(cityCount[p->v]<cityCount[cur.u]+1){\n                    cityCount[p->v]=cityCount[cur.u]+1;\n                }\n            }\n        }\n    }\n\n    //输出\n    for(int i=1;i<=n;++i){\n        printf(\"%d%c\",dist[i],i==n?'\\n':' ');\n    }\n    for (int i = 1; i<=n; ++i)\n    {\n        printf(\"%d%c\",cityCount[i],i==n?'\\n':' ');\n    }\n    return 0;\n}\n```\n\n##### 分析  \n\n在样例代码中，使用了堆优化来提高Dijkstra算法的效率，加速了找最小权边的时间。  \n\n## 总结  \n\n此次实验与实战，可以发现对于审题还是需要仔细，如：<font color=#ff0000>无向图，求值还是路径</font>  等问题对于思路的影响较大。  \n\n其次，有丰富的代码模板储备真的能提速不少解题速度。  \n\n","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第四次解题报告"]},{"title":"数据结构-第三次解题报告","url":"/posts/b77e3ad9/","content":"\n## 第一题:二叉树最长路径\n\n给定一颗二叉树，求T中的最长路径的长度，并输出此路径上各个节点的值，若有多条路径，输出最右侧的那条。  \n\n### 输入格式 <img align=\"right\" src=\"数据结构-第三次解题报告/1.png\">\n\n第1行，1个整数n，表示二叉树有n个结点， 1≤n≤100000.  \n第2行，2n+1个整数，用空格分隔，表示T的扩展先根序列， -1表示空指针，结点用编号1到n表示。  \n### 输出格式\n\n第1行，1个整数length，length表示T中的最长路径的长度。  \n第2行，length+1个整数，用空格分隔，表示最右侧的最长路径  \n\n### 输入样例\n\n```plain\n5\n1 2 -1 -1 3 4 -1 -1 5 -1 -1\n```\n\n### 输出样例\n\n```plain\n2\n1 3 5\n```\n\n<!--more-->\n\n### 题目解析\n\n首先，考虑到树中的最长路径，我们可以想到是应该是使用深度遍历  \n\n#### 方法一:无树暴力法\n\n观察输入的序列，我们发现它是先根序遍历树而产生的，所以显然的，当我们读入序列时就相当于以先根序深度搜索(DFS)树了，当遇到-1时我们，我们便认为到了树的末端，进行一次最长路径判断。  \n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint Max=0;\nvector<int> path;\nvector<int> t_path;\n\nvoid createTree(int n){\n\n    int itemp=0;\n    scanf(\"%d\",&itemp);\n    getchar();\n    if(itemp==-1){\n        if(n>=Max){\n            Max=n;\n            path=t_path;\n        }\n        return;\n    } \n    t_path.push_back(itemp);\n    createTree(n+1);\n    createTree(n+1);\n    t_path.pop_back();\n    return ;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    createTree(0);\n    printf(\"%d\\n\",Max-1);\n    for(int i=0;i<path.size();++i){\n        printf(\"%d\",path[i]);\n        if(i<path.size()-1){\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n##### 分析\n\n每次都进行最长路判断的过程中，更改最优路径会消耗大量的时间,时间复杂度好像是O($n^2$),,考虑到时间限制是100ms，其中一个测试点通不过，所以这个算法效率着实有点低了 :sweat_smile:,不过有点很明显啊，空间效率比较高,最坏是O(n)，毕竟不用建树了。  \n\n#### 方法二: 最优子树路径(动态规划？)\n\n求最长路径就是求树高，所以如果每次都能走树高较高的子树，那自然而然的会有最长路径。所以我们应该求出每棵子树的树高。  \n\n为了偷懒，我们发现求子树的树高需要使用DFS，而求最长路径也是DFS，所以可以一起完成。  \n\n##### 代码实现\n\n```c++\n//使用动态规划，更具子树的高度来确定是否选择\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\npair<int,int> tree[100001]; //构建树\nint heigth[100001]; //保存对应子树的高度,默认高度为1;即自身\nint best[100001]={0};    //保存最优的选择。\n\n//构建树\nint initTree(){\n    int itemp=0;\n    scanf(\"%d\",&itemp);\n    getchar();\n    if(itemp!=-1){\n        tree[itemp].first=initTree();\n        tree[itemp].second=initTree();\n    }\n    return itemp;\n}\n\nvoid dfs(int root){\n    if(root==-1){\n        return; //代表到达底部了\n    }else{\n        heigth[root]=1; //全局变量只能初始化为0 爬；\n        //如果有左子树，从左侧开始遍历，以确保最后的结果是最右侧的\n        if(tree[root].first!=-1){\n            dfs(tree[root].first);  //在左子树中求最优选择和高度\n            heigth[root]=max(heigth[root],heigth[tree[root].first]+1);  //更新该节点的高度\n            best[root]=tree[root].first;    //认为最优的是左子树。\n        }\n        //若右子树存在\n        if(tree[root].second!=-1){\n            dfs(tree[root].second); //求右子树的最优选择和高度\n            heigth[root]=max(heigth[root],heigth[tree[root].second]+1);\n            //如果左子树不存在，或者右侧树更高则选择右侧，相等也选择右侧，因为要右侧的结果\n            if(tree[root].first==-1||heigth[tree[root].second]>=heigth[tree[root].first]){\n                best[root]=tree[root].second;   //置为右子树\n            }\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int root=initTree();    //输入并构建树\n    dfs(root);  //进行求解\n\n    printf(\"%d\\n\",heigth[root]-1);  //因为默认一个节点高度为1所以减一\n    //best中的就是最优路径\n    while (root!=0)\n    {\n        printf(\"%d\",root);\n        root=best[root];    //走向下一个\n        if(root!=0)printf(\" \"); //若下一个节点不是0则就还没到最后 打印空格\n    }\n    \n    printf(\"\\n\");\n    return 0;\n}\n\n```\n##### 分析\n\n相当于使用2遍DFS，所以时间复杂度是O(n)的，已经足以AC了。\n\n## 题目二:森林的层次遍历\n\n给定一个森林F，求F的层次遍历序列。森林由其先根序列及序列中每个结点的度给出。  \n\n### 输入格式<img align=\"right\" src=\"数据结构-第三次解题报告/1.png\">\n\n第1行，1个整数n，表示森林的结点个数， 1≤n≤100000.  \n第2行，n个字符，用空格分隔，表示森林F的先根序列。字符为大小写字母及数字。  \n第3行，n个整数，用空格分隔，表示森林F的先根序列中每个结点对应的度。  \n\n### 输出格式\n\n1行，n个字符，用空格分隔，表示森林F的层次遍历序列。  \n\n### 输入样例\n\n在这里给出一组输入。例如:  \n```plain\n14\nA B C D E F G H I J K L M N\n4 0 3 0 0 0 0 2 2 0 0 0 1 0\n```\n\n### 输出样例\n\n在这里给出相应的输出,例如:  \n```plain\nA M B C G H N D E F I L J K\n```\n\n### 题目解析\n\n#### 方法一:建立森林后层次遍历\n\n显然的，可以通过给出的序列建立一个森林，然后引入一个虚根节点，将所有树的根链接到虚根上，就可以用树的层次遍历法进行遍历。  \n\n##### 代码实现\n\n~~没有代码实现~~  （这个基本功啦，自己实现啊kora~）  \n\n##### 分析\n\n显然的，从整体考虑，就是O(n),将所有节点都访问个2遍呗。就是申请n次空间相对比较慢。  \n\n#### 方法二:无森林层序遍历\n\n我们又观察序列，我们发现这个序列是深度遍历的结果，但是每个节点的层次都十分明显，所以我们只要模拟序列层次的跳转过程就可以将每个节点分配到对应的层上去。  \n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<stack>\n#include<queue>\n\nusing namespace std;\nint count=0;\nint n=0;\n\nvector<pair<char,int>> list;\n\nstruct layer\n{\n    queue<char> list;\n    layer* next;\n    layer(){\n        next=NULL;\n    }\n};\n\nlayer * initForest(layer * root,int x){\n    if(count>=n){\n        return NULL;\n    }\n    if(root==NULL)root=new layer;\n    for(int i=0;count<n&&i<x;++i){\n        int target=count;\n        ++count;\n        root->list.push(list[target].first);\n        if(list[target].second>0){\n            root->next=initForest(root->next,list[target].second);\n        }\n    }\n    return root;\n}\nint main(int argc, char const *argv[])\n{\n    scanf(\"%d\",&n);\n    getchar();\n\n    char ctemp=0;\n    for(int i=0;i<n;++i){\n        scanf(\" %c\",&ctemp);\n        list.push_back(pair<char,int>(ctemp,0));\n    }\n    int itemp=0;\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\" %d\",&itemp);\n        list[i].second=itemp;\n    }\n    layer* root=NULL;\n    root=initForest(root,n);\n    bool flag=true;\n    while (root!=NULL)\n    {\n        while (!root->list.empty())\n        {\n            \n            if(flag){\n                printf(\"%c\",root->list.front());\n                flag=false;\n            }else{\n                printf(\" %c\",root->list.front());\n            }\n            root->list.pop();\n        }\n        root=root->next;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n```\n\n##### 分析\n\n简单分析可得，时间复杂度也是O(n)，每个节点也是访问2次，空间复杂度也没太大区别，也是O(n)，少了几个指针域罢了，就节省了一半申请新空间的时间。~~并没什么软用~~  \n但是从这个思路中，结合第一题我们可以发现，很多时候，给出的树的序列中隐藏了很多有用的信息，充分利用这些信息就能写出神奇的代码。  \n\n## 第三题:纸带切割\n\n有一条细长的纸带,长度为 L 个单位，宽度为一个单位。现在要将纸带切割成 n 段。每次切割把当前纸带分成两段，切割位置都在整数单位上，切割代价是当前切割纸带的总长度。每次切割都选择未达最终要求的最长纸带切割，若这样的纸带有多条，则任选一条切割。如何切割，才能完成任务，并且总代价最小。  \n\n### 输入格式<img align=\"right\" src=\"数据结构-第三次解题报告/1.png\">\n\n第1行，1个整数n，表示切割成的段数， 1≤n≤100000.  \n第2行，n个整数Li，用空格分隔，表示要切割成的各段的长度，1≤Li≤200000000，1≤i≤n.  \n\n### 输出格式 \n\n第1行，1个整数，表示最小的总代价。  \n第2行，若干个整数，用空格分隔，表示总代价最小时每次切割的代价。  \n\n### 输入样例\n\n在这里给出一组输入。例如:  \n```plain\n5\n5 6 7 2 4\n```\n\n### 输出样例\n\n在这里给出相应的输出。例如:  \n```plain\n54\n24 13 11 6\n```\n\n### 题目解析\n\n#### 方法一:暴力回溯法\n\n分析切割的过程，其实就是输入n个数的分组问题，可以使用回溯法来遍历所有的分组可能，来找到最优解  \n\n##### 代码实现\n\n回溯法的代码并不复杂，可以使用递归实现，此处因为偷懒就不给出了  \n\n##### 分析\n\n回溯法的时间复杂度是O(n!),这就很恐怖了，这样的代码不写也罢。  \n\n#### 方法二:逆哈夫曼树\n\n考虑到代价就是所切纸带的长度，我们可以采用逆向思维，那代价就是将2段小纸带合成大纸带后的长度，这样的最小问题，我们应该能想到哈夫曼树。所以这道题的关键就是能使用逆向思维来思考问题.  \n{% note info %}\n**提示**\n1.其实并不需要实际，建立哈夫曼树，我们只是需要其顺序\n2.在选取最小2个节点的过程中，应使用堆优化，例如优先队列\n{% endnote %}\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\nstruct node\n{\n    long long info;\n    node(long long _info){\n        info=_info;\n    }\n    friend bool operator< (const node& a,const node& b){\n        return a.info>b.info;\n    }\n};\n\n//堆优化\npriority_queue<node> list;\n\nint main(int argc, char const *argv[])\n{\n    //输入\n    long long cost=0;\n    stack<long long> res_list;\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int itemp=0;\n    //入堆\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&itemp);\n        list.push(node(itemp));\n    }\n    //取堆中2个元素构建哈夫曼树\n    long long a=0;long long b=0; \n    while (list.size()>1)\n    {\n        //构建逻辑哈夫曼树\n        a=list.top().info;\n        list.pop();\n        b=list.top().info;\n        list.pop();\n        long long res_t=a+b;\n        list.push(res_t);\n        //将结果存入栈方便倒序输出\n        res_list.push(res_t);\n        cost+=res_t;\n    }\n\n    //输出结果\n    printf(\"%lld\\n\",cost);\n    while (!res_list.empty())\n    {\n        printf(\"%lld\",res_list.top());\n        res_list.pop();\n        if(res_list.empty()){\n            printf(\"\\n\");\n        }else{\n            printf(\" \");\n        }\n    }    \n    return 0;\n}\n\n```\n\n##### 分析\n\n简单分析，代价其实是建树代价，而建树代价最终是取最小2节点的代价，所以可以得出最坏时间复杂度是O($n\\log_2n$)，已经是非常快了。\n\n## 题目四:序列乘积\n\n两个递增序列A和B,长度都是n。令 Ai 和 Bj 做乘积，1≤i,j≤n.请输出n$\\times$n个乘积中从小到大的前n个。    \n\n### 输入格式<img align=\"right\" src=\"数据结构-第三次解题报告/1.png\">\n\n第1行，1个整数n，表示序列的长度， 1≤n≤100000.  \n第2行，n个整数Ai，用空格分隔，表示序列A，1≤Ai≤40000，1≤i≤n.  \n第3行，n个整数Bi，用空格分隔，表示序列B，1≤Bi≤40000，1≤i≤n.  \n\n### 输出格式\n\n1行，n个整数，用空格分隔，表示序列乘积中的从小到大前n个。  \n\n### 输入样例\n\n在这里给出一组输入。例如：  \n```plain\n5\n1 3 5 7 9 \n2 4 6 8 10\n```\n\n### 输出样例\n\n在这里给出相应的输出。例如；  \n```plain\n2 4 6 6 8\n```\n\n### 题目解析\n\n#### 方法一:暴力法\n\n将n$\\times$n个结果全部计算出来，然后排序，取前n个数。   \n\n##### 代码实现\n\n这里不给出具体实现，比较简单 \n\n##### 分析\n\n时间复杂度显然是O($n^2$)的，而且还要空间复杂度也是O($n^2$)的，就比较离谱，很容易超过限制  \n\n#### 方法二:利用二维递增性\n\n首先，注意到给出的2个序列都是单调递增的有序序列，结合我们学的二元函数，我们可以认为第一个序列代表了x轴方向上的递增性，第二个序列表示y轴方向上的递增性，所以我们知道在二维平面上有$x\\times y$随着距离原点距离的增大而递增，所以可以想到，使用一个区域圈出最小的n个值，如果能求出最缓增速方向，那沿着这个方向上的数就是所求的最小n个数。   \n\n但是，没得这种方法，我们应该使用试探法来找出这个区域 ，所以可以先假设有个包含原定的区域有最小的n个数，然后从中取出一个最小的数，再将此最小数周围的最小数加入这个其中。  \n\n为了方便，我们选择这个区域大小为n，同时初始假设为$a[0]\\times b[i](i=0,1,2,\\cdots)$ 当然你也可以选择别的符合条件的初始区域。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<long long,pair<int,int>> yurzi;\nint a_list[100001];\nint b_list[100001]; //不能用vector 爬\npriority_queue<yurzi,vector<yurzi>,greater<yurzi>> section;  //将a与b的乘积存于一个区间中，充分利用乘积的二维方向上的递增关系\n\nint main(int argc, char const *argv[])\n{\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\",&a_list[i]);\n        getchar();\n    }\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\",&b_list[i]);\n        getchar();\n    }\n\n    //可以先求出一维方向上最小的n个数\n    for(int i=0;i<n;++i){\n        section.push(yurzi(a_list[0]*b_list[i],pair<int,int>(0,i)));\n    }\n\n    //然后随着输出，逐渐拓展二维方向上的\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%lld\",section.top().first);\n        int a=section.top().second.first;\n        int b=section.top().second.second;\n        section.pop();\n        if(a+1<n){\n            section.push(yurzi(a_list[a+1]*b_list[b],pair<int,int>(a+1,b)));\n        }\n        if(i<n-1){\n            printf(\" \");\n        }else{\n            printf(\"\\n\");\n        }\n\n    }\n    return 0;\n}\n\n```\n\n##### 分析\n\n时间复杂度是O($n\\log_2n$)的，而空间复杂度是O(n)的。相较于暴力法，是巨大的进步。\n\n## 总结\n\n从这些题目中可以学习到，树序列的隐藏信息，逆向思维，结合数学知识的高维空间思维。","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第三次解题报告"]},{"title":"数据结构-第二次解题报告","url":"/posts/191b7708/","content":"\n## 第一题:数列查询\n\n已知数列的通项公式为:\n\nf(n) = f(n-1)*11/10，f[1]=10.\n\n通向从左向右计算，*和/分别表示整数乘法和除法。 现在，要多次查询数列项的值。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第二次解题报告/1.png\">\n\n第1行，1个整数q，表示查询的次数， 1≤q≤10000. 第2至q+1行，每行1个整数i，表示要查询f(i)的值。\n\n### 输出格式\n\nq行，每行1个整数，表示f(i)的值。查询的值都在32位整数范围内。\n\n### 输入样例\n\n这里给出一组输入，例如:\n\n```plain\n3\n1\n2\n3\n```\n\n### 输出样例\n\n这里给出相应的输出，例如：\n\n```plain\n10\n11\n12\n```\n\n<!--more-->\n\n### 题目解析\n\n题干中明确提到会多次查询(次数还挺多)，而且这道题的时间限制其实是10ms，假如每次输入一个数，就通过递归来求出结果，那时间复杂度是O(nq)阶即O($n^2$)的，这消耗的时间太多了，如果通过求通项然后再计算每次的结果，那分析式子可以知道，存在次幂运算，那时间还是O($n^2$)的。所以显然的，我们得想办法减少计算量，所以很自然的就会想到，将前面的结果缓存起来给后面使用，算是空间换时间，这里我使用了带记忆的递归来实现。\n\n#### 方法一:带记忆的递归\n\n用这种方法，比较符合自然思想的规律~~*不用怎么动脑*~~\n\n##### 代码实现：\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint res[10001];\nint toslove(int n){\n    if(n==1){\n        return res[n];\n    }\n    if(res[n]<=0){\n        res[n]=(toslove(n-1)*(double)11/10);\n    }\n    return res[n];\n}\n\nint main(){\n    res[1]=10;\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int t=0;\n    for (int i = 0; i <n; ++i)\n    {\n        scanf(\"%d\",&t);\n        getchar();\n        printf(\"%d\",toslove(t));\n        if(i<n-1)cout<<\"\\n\";\n    }\n}\n```\n\n##### 分析\n\n使用了递归，代码确实简单易懂，但是还可以通过消递归进一步优化，可以转为迭代算法。摊还后每次查找的代价趋于常数阶。\n\n#### 方法二:全结果缓存\n\n将范围内所有结果计算出来，存在数组中，这样每次查询的代价是常数阶的。\n\n为了进一步优化空间，我们对结果数进行估计，看到给出的数据类型是为32位整形且为非负数\n\n所以显然的最大数据不可能超过$2^{31}$ 即$10\\times{\\frac{11}{10}}^n\\le2^{31}$可以解得$n\\lt203$，所以只需要求202项即可\n\n此处不给出代码，请读者自行尝试\n\n#### ~~方法三:全结果硬编码缓存~~\n\n~~我愿意称其为最强，无论如何，时间代价就是O(1),不是摊还后O(1)。你只需要写一个全结果生成程序，然后将其按数组支持的初始化方式写入文件，最后在程序中初始化数组时使用文件中的结果初始化，效率直接爆炸，就是代码长度太长了。~~\n\n## 第二题:稀疏矩阵之和\n\n矩阵A和B都是稀疏矩阵。请计算矩阵的和A+B.如果A、B不能做和，输出\"`Illegal!`\"\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第二次解题报告/2.png\">\n\n矩阵的输入采用三元组表示，先A后B。对每个矩阵：\n\n第1行，3个整数N、M、t，用空格分隔，分别表示矩阵的行数、列数和非0数据项数，10≤N、M≤50000，t≤min(N,M).\n\n第2至t+1行，每行3个整数r、c、v，用空格分隔，表示矩阵r行c列的位置是非0数据项v, v在32位有符号整型范围内。三元组默认按行列排序。\n\n### 输出格式\n\n矩阵A+B，采用三元组表示，默认按行列排序，非零项也在32位有符号整型范围内\n\n### 输入样例\n\n```plain\n10 10 3\n2 2 2\n5 5 5\n10 10 20\n10 10 2\n2 2 1\n6 6 6\n```\n\n### 输出样例\n\n```plain\n10 10 4\n2 2 3\n5 5 5\n6 6 6\n10 10 20\n```\n\n### 题目解析\n\n首先题目指明了使用三元组来存储矩阵并对矩阵进行加法运算。而计算的关键是找到对应位置的元素，为此有2中方法。\n\n{% note warning no-icon %}\n对于计算后结果为0的元素，应当予以屏蔽或删除\n{%endnote%}\n\n#### 方法一:使用Map优化查找\n\nMap用来优化查找确实好用，而且直接调用stl十分省事。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<pair<int,int>,int32_t> yurzi;\n\nstruct cmp\n{\n    bool operator()(const pair<int,int> &a,const pair<int,int> &b)const{\n        if(a.first==b.first){\n            return a.second<b.second;\n        }\n        return a.first<b.first;\n    }\n};\nint main(int argc, char const *argv[])\n{\n    map<pair<int,int>,int32_t,cmp> a;\n    int n1=0,m1=0,t1=0;\n    scanf(\"%d %d %d\",&n1,&m1,&t1);\n    getchar();\n    int r=0,c=0;\n    int32_t v=0;\n    for(int i=0;i<t1;++i){\n        scanf(\"%d %d %d\",&r,&c,&v);\n        getchar();\n        a.insert(yurzi(pair<int,int>(r,c),v));\n    }\n    int n2=0,m2=0,t2=0;\n    scanf(\"%d %d %d\",&n2,&m2,&t2);\n    getchar();\n    if(t1>min(n1,m1)){\n        printf(\"Illegal!\");\n    }\n    if(n1==n2&&m1==m2&&t2>=0){\n        for (int i = 0; i < t2; ++i)\n        {\n            scanf(\"%d %d %d\",&r,&c,&v);\n            getchar();\n            auto iter=a.find(pair<int,int>(r,c));\n            if(iter!=a.end()){\n                iter->second=iter->second+v;\n                if(iter->second==0){\n                    a.erase(iter);\t//删除为0的元素\n                }\n            }\n            else{\n                a.insert(yurzi(pair<int,int>(r,c),v));\n            }\n        }\n        map<pair<int,int>,int>::iterator p;\n        p=a.begin();\n        printf(\"%d %d %d\\n\",n1,m1,a.size());\n        for (int i = a.size(); i >0; --i)\n        {\n            printf(\"%d %d %d\\n\",p->first.first,p->first.second,p->second);\n            p++;\n        }\n        \n    }else{\n        printf(\"Illegal!\");\n    }\n    \n    return 0;\n}\n```\n\n##### 分析\n\n鉴于Map的查找性能非常高，我们可以认为整个的时间复杂度为O(n)的，算是比较高效。\n\n#### 方法二:归并求和\n\n鉴于输入数据具有顺序性，我们可以使用类似于归并排序的方式来进行求及输出(输出时屏蔽0)，此处不给出代码。\n\n##### 分析\n\n使用归并的方法总的来说也只是遍历了一遍，时间复杂度是O(n)的，但是相较于Map效率稍高，空间效率在矩阵大小较大时低于Map。\n\n## 第三题:文字编辑\n\n一篇文章由n个汉字构成，汉字从前到后依次编号为1，2，……，n。 有四种操作：\n\nA i j表示把编号为i的汉字移动编号为j的汉字之前；\n\nB i j表示把编号为i的汉字移动编号为j的汉字之后；\n\nQ 0 i为询问编号为i的汉字之前的汉字的编号；\n\nQ 1 i为询问编号为i的汉字之后的汉字的编号。\n\n规定：1号汉字之前是n号汉字，n号汉字之后是1号汉字。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第二次解题报告/3.png\">\n\n第1行，1个整数T，表示有T组测试数据， 1≤T≤9999.\n\n随后的每一组测试数据中，第1行两个整数n和m，用空格分隔，分别代表汉字数和操作数，2≤n≤9999，1≤m≤9999；第2至m+1行，每行包含3个常量s、i和j，用空格分隔，s代表操作的类型，若s为A或B，则i和j表示汉字的编号，若s为Q，i代表0或1，j代表汉字的编号。\n\n### 输出格式\n\n若干行，每行1个整数，对应每个询问的结果汉字编号\n\n###  输入样例\n\n这里给出一组输入。例如：\n\n```plain\n1 \n9999 4 \nB 1 2  \nA 3 9999\nQ 1 1\nQ 0 3\n```\n\n### 输出样例\n\n在这里给出相应的输出。例如：\n\n```plain\n4\n9998\n```\n\n### 题目解析\n\n首先注意到时间限制，1s，再注意到题目中所说的第一个数前面是n，第n个数后面是第一个数。所以我们显然应该使用双向循环链表来实现，同时，还应该用数组来实现双向循环链表，如果使用链表结构，那查找对应位置的节点将会消耗大量的实现。\n\n#### 代码实现\n\n```c++\n#include<iostream>\n\nusing namespace std;\n\nstruct node\n{\n\tint prv;\n\tint next;\n};\n\nnode list[10001];\n\nvoid refresh(int n){\n\tfor(int i=1;i<=n;++i){\n\t\tif(i==1){\n\t\t\tlist[i].prv=n;\n\t\t}else{\n\t\t\tlist[i].prv=i-1;\n\t\t}\n\t\tif(i==n){\n\t\t\tlist[i].next=1;\n\t\t}else{\n\t\t\tlist[i].next=i+1;\n\t\t}\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tint t=0;\n\tscanf(\"%d\",&t);\n\twhile (getchar()!='\\n')\n\t{\n\t}\n\t\n\tfor (int i = 0; i <t; ++i)\n\t{\n\t\tint n=0,m=0;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\twhile (getchar()!='\\n')\n\t\t{\n\t\t}\n\t\trefresh(n);\n\t\tchar ctemp=0;\n\t\tint ope1=0,ope2=0;\n\t\tfor (int j = 0;j<m; ++j)\n\t\t{\n\t\t\tscanf(\"%c %d %d\",&ctemp,&ope1,&ope2);\n\t\t\twhile (getchar()!='\\n')\n\t\t\t{\n\t\t\t}\n\t\t\tif(ctemp=='A'){\n\t\t\t\t//从链中摘除节点\n\t\t\t\tlist[list[ope1].prv].next=list[ope1].next;\n\t\t\t\tlist[list[ope1].next].prv=list[ope1].prv;\n\t\t\t\t//将节点加入链中到ope2之前\n\t\t\t\tlist[ope1].prv=list[ope2].prv;\n\t\t\t\tlist[ope1].next=ope2;\n\t\t\t\tlist[list[ope1].prv].next=ope1;\n\t\t\t\tlist[ope2].prv=ope1;\n\t\t\t}else if (ctemp=='B')\n\t\t\t{\n\t\t\t\t//从链上摘下节点\n\t\t\t\tlist[list[ope1].prv].next=list[ope1].next;\n\t\t\t\tlist[list[ope1].next].prv=list[ope1].prv;\n\t\t\t\t//将节点加入到链中，ope2之后\n\t\t\t\tlist[ope1].prv=ope2;\n\t\t\t\tlist[ope1].next=list[ope2].next;\n\t\t\t\tlist[list[ope1].next].prv=ope1;\n\t\t\t\tlist[ope2].next=ope1;\n\t\t\t}else if (ctemp=='Q')\n\t\t\t{\n\t\t\t\tif(ope1){\n\t\t\t\t\tprintf(\"%d\\n\",list[ope2].next);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",list[ope2].prv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n#### 分析\n\n此处使用了，结构体，当然也可以使用2个数组分别存储对应数的前驱和后继。主要消耗时间的是每一组测试时的刷新数组，可以认为算法的时间复杂度是O($tn$)的。\n\n## 第四题:幸福指数\n\n人生中哪段时间最幸福?幸福指数可能会帮你发现。幸福指数要求：对自己每天的生活赋予一个幸福值，幸福值越大表示越幸福。一段时间的幸福指数就是：这段时间的幸福值的和乘以这段时间的幸福值的最小值。幸福指数最大的那段时间，可能就是人生中最幸福的时光。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第二次解题报告/4.png\">\n\n第1行，1个整数n，， 1≤n≤100000,表示要考察的天数。\n\n第2行，n个整数Hi，用空格分隔，Hi表示第i天的幸福值，0≤n≤1000000\n\n### 输出格式\n\n第1行，1个整数，表示最大幸福指数。\n\n第2行，2个整数l和r，用空格分隔，表示最大幸福指数对应的区间[l,r]。如果有多个这样的区间，输出最长最左区间。\n\n### 输入样例\n\n在这里给出一组输入。例如：\n\n```plain\n7\n6 4 5 1 4 5 6\n```\n\n### 输出样例\n\n在这里给出相应的输出，例如：\n\n```plain\n60\n1 3\n```\n\n### 题目解析\n\n分析题目可知，我们需要找出一个这样的区间，这个区间的和乘以区间最小值的结果是所有区间里最大的，所以关键是找到区间的左右端点，和该区间的最小值。但是题目要的是这样最大的区间，所以区间里在最小值要尽可能的大。换句话说，就是区间内没有比这个最小值还小的数了，同时这个最小值要尽可能的大的情况下，这样得出的结果就能满足要求。\n\n为什么？因为以较大数为最小值的区间定不包含小于该数的数而包含大于该数的数，这样使用归纳法就可证明枚举了所有的区间。\n\n#### 方法一:暴力法\n\n~~*暴力大法好啊*~~\n\n使用暴力法的话就是枚举每个数，并且找到每个数左侧小于它的数，找到右侧比它小的数，可谓是非常直观。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    vector<int> list;\n    vector<long long> sum;\n    list.push_back(-(__INT32_MAX__-1));\n    sum.push_back(0);\n\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int itemp=0;\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        list.push_back(itemp);\n        sum.push_back(sum[i-1]+itemp);\n    }\n    list.push_back(-(__INT32_MAX__-1));\n    int left_t=0; int right_t=0;\n    long long max=0,max_t=0;\n    int max_l=0,max_r=0;\n    for (int i = 1; i <=n; ++i)\n    {\n        left_t=0;right_t=n+1;\n        //往左侧找\n        for(int l=i;l>=0;--l){\n            if(list[l]<list[i]){\n                left_t=l;\n                break;\n            }\n        }\n        //往右侧找\n        for (int r = i; r<=n+1; ++r)\n        {\n            if(list[r]<list[i]){\n                right_t=r;\n                break;\n            }\n        }\n        //判断\n        max_t=list[i]*(sum[right_t-1]-sum[left_t]);\n        if(max_t>max){\n            max=max_t;\n            max_l=left_t+1;\n            max_r=right_t-1;\n        }else if (max==max_t){\n           if(max_r-max_l<right_t-left_t-2){\n                max_l=left_t+1;\n                max_r=right_t-1;\n           }else if(left_t+1<max_l){\n                max_l=left_t+1;\n                max_r=right_t-1;               \n           } \n        }\n    }\n    printf(\"%lld\\n%d %d\",max,max_l,max_r);\n    return 0;\n}\n```\n\n##### 分析\n\n结果非常的令人amazing啊！暴力法在此题的测试下竟然只有最后一个没过，着实令人惊讶。分析时间复杂度我们发现是O($n^2$)的所有效率上肯定是不足的，加上这题的时间限制为100ms，数据量一大就会超时。\n\n#### 方法二:单调栈\n\n在上述分析过程中我们发现，可优化的耗时部分是寻找区间的左右端点，即找到左右第一个小于目标数的值，对于这种问题，我们可以使用单调栈来解决。\n\n使用严格递增的单调栈，能保证栈顶的元素定小于目标元素的。鉴于左右都需要，我们可以左右都使用一遍单调栈，并将每个数的区间储存起来。从而再枚举各个数得出结果。\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    vector<int> list;\n    vector<int> left;\n    vector<int> right;\n    list.push_back(-(__INT32_MAX__-1));\n    left.push_back(0);\n    right.push_back(0);\n    vector<long long> sum;\n    stack<int> temp;\n    sum.push_back(0);\n    \n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    \n    int itemp=0;\n    //输入数据\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        list.push_back(itemp);\n        left.push_back(i);\n        right.push_back(i);\n\n        sum.push_back(sum[i-1]+itemp);  //使用前缀和数组优化计算\n    }\n    list.push_back(-(__INT32_MAX__-1));\n    //从左侧使用单调栈遍历\n    temp.push(0);\n    for(int i=1;i<=n;++i){\n        //使用严格的单调递增栈\n        while (!temp.empty()&&list[temp.top()]>=list[i])\n        {\n            temp.pop();\n        }\n\n        left[i]=temp.top();\n        temp.push(i);\n    }\n    //清空栈\n    while (!temp.empty())\n    {\n        temp.pop();\n    }\n    temp.push(n+1);\n    for (int i = n; i >= 1; --i)\n    {\n        //使用严格的单调递增栈\n        while (!temp.empty()&&list[temp.top()]>=list[i])\n        {\n            temp.pop();\n        }\n\n        right[i]=temp.top();\n        temp.push(i);\n    }\n    long long max=0,max_t=0;\n    int max_l=0,max_r=0;\n\n    for(int i=1;i<=n;++i){\n        max_t=list[i]*(sum[right[i]-1]-sum[left[i]]);\n        if(max_t>max){\n            max=max_t;\n            max_l=left[i]+1;\n            max_r=right[i]-1;\n        }else if (max==max_t){\n           if(max_r-max_l<right[i]-1-left[i]-1){\n                max_l=left[i]+1;\n                max_r=right[i]-1;\n           }else if(left[i]+1<max_l){\n                max_l=left[i]+1;\n                max_r=right[i]-1;\n           } \n        }\n        \n    }\n    printf(\"%lld\\n%d %d\",max,max_l,max_r);\n    return 0;\n}\n```\n\n##### 分析\n\n虽然代码中含有很多的循环，但是时间复杂度是O(n)阶的，不容易随着n的增加而大量消耗时间，相较于暴力法优化了不少。是一种空间换时间的方法\n\n{% note info %}\n**提示**\n__INT32_MAX__是 32位整形的最大值。\n要将保存原始数据的左右2端加上负无穷的数，以方便单调栈的比较。\n{% endnote %}\n","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第二次解题报告"]},{"title":"数据结构:第一次解题报告","url":"/posts/a62b4006/","content":"\n## 第一题:重复计数\n\n在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。\n<img align=\"right\" src=\"数据结构-第一次解题报告/first.png\">\n\n### 输入格式 \n第1行，1个整数N，表示整数的个数，(1≤N≤50000)。\n第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤2000000000。\n\n### 输出格式\n\n若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。\n\n### 输入样例\n\n在这里给出一组输入。例如:\n\n```plain\n12\n8 2 8 2 2 11 1 1 8 1 13 13\n```\n\n### 输出样例\n\n在这里给出相应的输出。例如:\n\n```plain\n8 3\n2 3\n11 1\n1 3\n13 2\n```\n\n<!--more-->\n\n### 题目解析\n\n#### 方法一:暴力法\n\n这个方法非常简单啊，一波暴力，直接将遍历现有的数组去查找然后有的增加计数，没有的就直接添加\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    vector<pair<int,int>> list;\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int itemp=0;\n    int t=0;\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        //搜索\n        int target=-1;\t//置为-1用作标记是否存在\n        for(int j=0;j<list.size();++j){\n            if(list[j].first==itemp){\n                target=j;\n            }\n        }\n        if(target){\n            list[target].second+=1;\n        }else{\n            list.push_back(pair<int,int>(itemp,1));\n        }\n    }\n    for (int i = 0; i < list.size(); ++i)\n    {\n        printf(\"%d %d\",list[i].first,list[i].second);\n        if(i<list.size()-1)printf(\"\\n\");\n    }\n    return 0;\n}\n\n```\n\n##### 分析\n\n显然的，这个时间复杂度是O($n^2$)的，非常低效，数据种类一多，就会被卡时间。那有没有优化的方法呢？显然是有的啦 ~~*这不是废话*~~\n\n#### 方法二：使用Map优化的统计法\n\n在暴力法中，查找数字花费了大量的时间，为了加速查找，使用STL中的Map是一个不错的选择，所以代码可以优化成这样\n\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    vector<pair<int,int>> list;\n    map<int,int> tofind;\n    int n=0;\n    scanf(\"%d\",&n);\n    getchar();\n    int itemp=0;\n    int t=0;\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        auto iter=tofind.find(itemp);\n        //使用Map来加速查找\n        if(iter==tofind.end()){\n            tofind.insert(pair<int,int>(itemp,t));\n            list.push_back(pair<int,int>(itemp,1));\n            ++t;\n        }else{\n            list[iter->second].second+=1;\n        }\n    }\n    for (int i = 0; i < list.size(); ++i)\n    {\n        printf(\"%d %d\",list[i].first,list[i].second);\n        if(i<list.size()-1)printf(\"\\n\");\n    }\n    return 0;\n}\n\n```\n\n#### 方法三:使用Multiset(集合)\n\n使用Multiset的方法其实与Map相差不大，可以用加入标记并重载排序函数来实现输入时顺序,其实Map也可以用同样的方式来排序  ~~*我是伞兵*~~ 此处就不在赘述。\n\n#### 方法四:使用排序和查找\n\n主要思路就是运用相同数字排序后会形成一个区间，从而只要以区间上界减去下界即可得到个数\n\n对于排序可以使用sort方法，而对于上下界也可以使用系统提供的lower_bound和upper_bound来获取，使用方法及代码请读者自行解决了，此处就提供一个思路~~*就是懒*~~\n\n\n\n## 第二题:报数游戏\n\n  n个人围成一圈，从1开始依次编号，做报数游戏。 现指定从第1个人开始报数，报数到第m个人时，该人出圈，然后从其下一个人重新开始报数，仍是报数到第m个人出圈，如此重复下去，直到所有人都出圈。总人数不足m时将循环报数。请输出所有人出圈的顺序。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第一次解题报告/second.png\">\n\n一行，两个整数n和m。n表示游戏的人数，m表示报数出圈的数字，1≤n≤50000，1≤m≤100.\n\n### 输出格式\n\n一行，n个用空格分隔的整数，表示所有人出圈的顺序\n\n### 输入样例\n\n```plain\n5 2\n```\n\n### 输出样例\n\n```plain\n2 4 1 5 3\n```\n\n### 题目解析\n\n从本质上来说，这就是约瑟夫问题，对于约瑟夫问题使用循环链表来解决是一个很好的方法。但是使用循环数组也可以实现，但是考虑到数组维护的复杂度还不如手撸一个链表来的快:sweat_smile:\n\n#### 方法一：循环链表(数组)\n\n##### 代码实现\n\n```c\n//建立循环链表\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct Node{\n    int num;\n    struct Node * next;\n}Person;\n//创建循环链表\nPerson* initLink(int n){\n    int i=0;\n    Person* head=NULL,*cyclic=NULL;\n    head=(Person*)malloc(sizeof(Person));\n    head->num=1;\n    head->next=NULL;\n    cyclic=head;\n    //建立n个节点的循环链表\n    for(int i=2;i<=n;i++){\n        Person* body=(Person*)malloc(sizeof(Person));\n        body->num=i;\n        body->next=NULL;\n        cyclic->next=body;\n        cyclic=cyclic->next;\n    }\n    cyclic->next=head;//首尾相连\n    return head;\n}\n//删去报到的人\nvoid findAndDel(Person* head,int s,int m){\n    Person* point=NULL;\n    Person* tail=head;\n    //找到上一个节点\n    while(tail->next!=head){\n        tail=tail->next;\n    }\n    //从头开始\n    point=head;\n    //找到编号为s的人\n    while(point->num!=s){\n        tail=point;\n        point=point->next;//将point移动到下一个链表元素\n    }\n    //从编号为s的人开始 只有符合point->next==point时,说明处P外全出列了\n    while(point->next!=point){\n        int i=0;\n        //从point所指的人开始报数,找到报m-1的人,方便删除\n        for(i=1;i<m;i++){\n            tail=point;\n            point=point->next;\n        }\n        //此时point所指的即为要杀死的人,摘除这个节点\n        tail->next=point->next;\n        printf(\"%d \" ,point->num);\n        //释放空间\n        free(point);\n        //将point指向下一个人\n        point=tail->next;\n        \n    }\n    //最后只剩下一个人\n    printf(\"%d\",point->num);\n    free(point);\n}\n\n\nint main(int argc, char const *argv[])\n{\n    int n=0,s=1,m=0;\n    Person* head=NULL;\n    scanf(\"%d %d\",&n,&m);\n    head=initLink(n);\n    findAndDel(head,s,m);\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n##### 分析\n\n总的来说，算是链表构建的时间，时间复杂度是O(n)的，当然用数组实现也是一样的。还是很nice 的\n\n## 第三题:算术表达式计算\n\n任务: 计算算术表达式的值。\n\n算术表达式按中缀给出，以=号结束，包括+,-,,/四种运算和(、)分隔符。运算数的范围是非负整数，没有正负符号，小于等于109 。\n\n计算过程中,如果出现除数为0的情况,表达式的结果为”NaN” ; 如果中间结果超出32位有符号整型范围,仍按整型计算，不必特殊处理。 输入保证表达式正确。\n\n### 输入格式 <img align=\"right\" src=\"数据结构-第一次解题报告/third.png\">\n\n一行，包括1个算术表达式。算术表达式的长度小于等于1000。\n\n### 输出格式\n\n一行，算术表达式的值 。\n\n### 输入样例\n\n```plain\n(1+30)/3=\n```\n\n### 输出样例\n\n```plain\n10\n```\n\n### 题目解析\n\n显然的对于这种题目，关键点就是前缀表达式转化为后缀表达式进行计算。可以先求后缀式，再求结果但是也可以结合起来，节省时间。\n\n#### 代码实现\n\n```c++\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstack<int> num;\nstack<int> oper;\n\nbool cmpPriority(char a, char b)\n{\n    if (b == '*' || b == '/')\n    {\n        if (a == '+' || a == '-' || a == '(')\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    if (b == '+' || b == '-')\n    {\n        if (a == '*' || a == '/')\n        {\n            return false;\n        }\n        else\n        {\n            if (a == '(')\n            {\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n    }\n    if (a == '(')\n    {\n        return true;\n    }\n    return true;\n}\n\nvoid poponeOpe(char ope)\n{\n    int a = 0;\n    int b = 0;\n    switch (ope)\n    {\n    case '+':\n        a = num.top();\n        num.pop();\n        b = num.top();\n        num.pop();\n        num.push(b + a);\n        break;\n    case '-':\n        a = num.top();\n        num.pop();\n        b = num.top();\n        num.pop();\n        num.push(b - a);\n        break;\n    case '*':\n        a = num.top();\n        num.pop();\n        b = num.top();\n        num.pop();\n        num.push(a * b);\n        break;\n    case '/':\n        a = num.top();\n        num.pop();\n        b = num.top();\n        num.pop();\n        if (a == 0)\n        {\n            printf(\"NaN\");\n            exit(0);\n        }\n        num.push(b / a);\n        break;\n        break;\n    default:\n        break;\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    stack<int> &tosee = num;\n    stack<int> &app = oper;\n    char ctemp = 0;\n    char ope = 0;\n    int res = 0;\n    int itemp = 0;\n    bool flag = true;\n    while (flag)\n    {\n        res = -1;\n        itemp = 0;\n        while (1)\n        {\n            ctemp = getchar();\n            if (ctemp >= '0' && ctemp <= '9')\n            {\n                itemp = itemp * 10 + int(ctemp - 48);\n                res = itemp;\n            }\n            else\n            {\n\n                if (ctemp == '=')\n                {\n                    flag = false;\n                }\n                break;\n            }\n        }\n\n        if (res > -1)\n        {\n            num.push(res);\n        }\n        if (oper.empty())\n        {\n            oper.push(ctemp);\n        }\n        else\n        {\n            if (ctemp == '(')\n            {\n                oper.push(ctemp);\n            }\n            else if (ctemp == ')')\n            {\n                while ('(' != oper.top())\n                {\n                    ope = oper.top();\n                    poponeOpe(ope);\n                    oper.pop();\n                }\n                oper.pop();\n            }\n            else if (cmpPriority(oper.top(), ctemp))\n            {\n                oper.push(ctemp);\n            }\n            else if (!cmpPriority(oper.top(), ctemp))\n            {\n\n                while (!cmpPriority(oper.top(), ctemp))\n                {\n\n                    ope = oper.top();\n                    poponeOpe(ope);\n                    oper.pop();\n                    if (oper.empty())\n                        break;\n                }\n                oper.push(ctemp);\n            }\n        }\n    }\n    while (!oper.empty())\n    {\n        ope = oper.top();\n        poponeOpe(ope);\n        oper.pop();\n    }\n\n    printf(\"%d\", num.top());\n    return 0;\n}\n```\n\n#### 分析\n\n总体来说，只是将整个字符串扫描了一遍，设字符串长度为n，时间复杂度为O(n)的。\n\n## 题目四:最喜爱的序列\n\n小唐这段时间在研究序列。拿来N个整数的序列，他给序列中的每个整数都赋予一个喜爱值。喜爱值也是整数，有正有负，越大表明越喜欢。他想知道，如何从序列中连续取最多m个数，他获得喜爱值最大。1≤N≤500000，1≤m≤N。  \n\n### 输入格式 <img align=\"right\" src=\"数据结构-第一次解题报告/forth.png\">\n\n第一行是两个整数N,m。分别代表序列中数的个数以及能取的最多个数。  \n第二行用空格隔开的N个整数，第i个整数Li代表他对第i个数的喜爱值。│Li│≤1000  \n\n### 输出格式\n\n一行，三个数，表示获得最大喜爱值，及第一个取最大喜爱值的区间。\n\n### 输入样例\n\n```plain\n5 2\n1 4 5 2 3\n```\n\n### 输出样例\n\n```plain\n9 2 3\n```\n<!--more-->\n\n### 题目解析\n\n这个问题本质上就是求最大连续子数列的和,其中连续取最多m个整数限制了区间的范围\n\n#### 方法一:暴力法\n\n暴力法解决这个问题无非就是遍历所有可能的子序列并计算其和\n用嵌套的for循环来实现遍历。\n\n##### 代码实现\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int n=0;int m=0;    //用来存放输入的n和m\n    vector<int> list;   //存放输入的喜爱值\n\n    //读入数据\n    scanf(\"%d %d\",&n,&m);\n    getchar();  //去除回车 以防万一\n    int itemp=0;    //暂存读入的数据，用来加入vector\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        list.push_back(itemp);\n    }\n\n    int Max=0;  //保存最终的结果\n    int left=0;int right=0; //保存最大值的左右区间\n    int left_t=0;int right_t=0;\n    int max_t=0;    //用来保存每个子序列的最大值\n    int sum=0;  //用来保存每个子序列的和;\n    //遍历数据\n    for (int i = 0; i < n; ++i)\n    {\n        max_t=0;\n        sum=0;\n        int j=i;\n        for(j=i;j<i+m&&j<n;++j){\n            sum+=list[j];\n            if(sum>max_t){\n                max_t=sum;\n                left_t=i;\n                right_t=j;\n            }\n        }\n        if(max_t>Max){\n            Max=max_t;\n            left=left_t;\n            right=right_t;\n        }\n    }\n    printf(\"%d %d %d\",Max,left+1,right+1);\n    return 0;\n}\n```\n\n##### 分析:\n使用暴力法的时间复杂度显然是O(nm)的，这实在太慢了:sweat_smile:，~~*虽然还有更慢的*~~ 很容易被时间限制卡住。\n\n#### 方法二:单调队列\n\n要使用单调队列，我们需要引入一个前缀和序列。\n维护这样一个前缀和的单调队列，区间范围为m，则队列首元素为该区间中的最小值，用区间内的前缀和去减去这个最小值，则得到值最大的，为该序列中子序列的最大值\n**举个栗子**\n\n```plain\n对于数据\n5 2\n1 4 5 -1 3\n有前缀序列\n0,1,5,10,9,12\n维护一个单调非递减的单调序列\n1 [0],1,5,10,9,12   max=0;max!<0;max=0;\n2 [0,1],5,10,9,12   max=0;max<1-0;max=1;\n3 [0,1,5],10,9,12   max=1;max<5-0;max=5;\n以上行为每次进行一次队尾减去队首的值与max进行比较的操作。\n最开始的时候因为不满一个区间的长度(m+1,多了初始点0)所以不做操作\n4.1 [0,1,5,]10,9,12  此时超过区间的长度，即将要加入5，而5满足非递减的要求可以入队，否则弹出队尾元素直至可入队\n4.2 [0,1,5,10],9,12  此时维护区间 发现0已经在区间外了，*ps：现在指针指向的数为前缀和序列中的10* 将队首元素弹出队列\n4.3 0,[1,5,10],9,12  max=5;max<10-1;max=9;\n5.1 0,[1,5,10,]9,12  9显然不满足要求\n5.2 0,[1,5]10,[9],9,12  维护区间\n5.3 0,1,[5]10,[9],12 max=9;max!<9-5;max=9;\n......\n直至运行结束\n```\n##### 代码实现\n\n```c++\n#include<iostream>\n#include<vector>\n#include<deque>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int n=0;int m=0;    //用来存放输入的n和m\n    vector<int> preSum; //保存前缀和    并不需要保存喜欢值序列\n    deque<pair<int,int>> MQueue;    //单调队列  first 存储数据 second 存储下标\n    int Max=0;\n    int left=0;int right=0;\n\n    //读入数据\n    scanf(\"%d %d\",&n,&m);\n    getchar();  //去除回车 以防万一\n    int itemp=0;    //暂存读入的数据，用来加入vector\n    preSum.push_back(0);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        preSum.push_back(preSum[i-1]+itemp);\n    }\n    for(int i=0;i<=n;++i){\n        //入队并维持单调性\n        if(MQueue.empty()||preSum[i]>=MQueue.back().first){\n            MQueue.push_back(pair<int,int>(preSum[i],i));\n        }else{\n            while (!MQueue.empty()&&MQueue.back().first>preSum[i])\n            {\n                MQueue.pop_back();\n            }\n            MQueue.push_back(pair<int,int>(preSum[i],i));\n        }\n        //维护区间\n        if(i>=m){\n            while (!MQueue.empty()&&MQueue.front().second<i-m)\n            {\n                MQueue.pop_front();\n            }\n        }\n\n        //与max进行比较\n        if(Max<MQueue.back().first-MQueue.front().first){\n            Max=MQueue.back().first-MQueue.front().first;\n            left=MQueue.front().second;\n            right=MQueue.back().second;\n        }\n\n    }\n    printf(\"%d %d %d\",Max,left+1,right);\n    return 0;\n}\n```\n\n##### 分析\n因为每个前缀和序列中的元素只被访问了一次，时间复杂度是O(n),可以看到相比暴力穷举法，时间效率大大的提高了。如果使用数组自己维护双端队列 则空间还可以节省三分之一 ~~*我是five懒得写了*~~\n\n**更多思路可以看[这里]([http://blog.yurzi.net/2021/05/09/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/](http://blog.yurzi.net/2021/05/09/最大连续子序列和/))**","tags":["数据结构与算法","总结"],"categories":["数据结构与算法","报告","第一次解题报告"]},{"title":"最大连续子序列和","url":"/posts/7e7e02b7/","content":"\n---\n\n## 题目:最喜爱的序列\n\n小唐这段时间在研究序列。拿来N个整数的序列，他给序列中的每个整数都赋予一个喜爱值。喜爱值也是整数，有正有负，越大表明越喜欢。他想知道，如何从序列中连续取最多m个数，他获得喜爱值最大。1≤N≤500000，1≤m≤N。  \n\n### 输入格式 \n\n第一行是两个整数N,m。分别代表序列中数的个数以及能取的最多个数。  \n第二行用空格隔开的N个整数，第i个整数Li代表他对第i个数的喜爱值。│Li│≤1000  \n\n### 输出格式\n\n一行，三个数，表示获得最大喜爱值，及第一个取最大喜爱值的区间。\n\n### 输入样例\n\n```plain\n5 2\n1 4 5 2 3\n```\n\n### 输出样例\n\n```plain\n9 2 3\n```\n<!--more-->\n### 题目解析\n\n这个问题本质上就是求最大连续子数列的和,其中连续取最多m个整数限制了区间的范围\n\n#### 方法一:暴力法\n\n暴力法解决这个问题无非就是遍历所有可能的子序列并计算其和\n用嵌套的for循环来实现遍历。\n**代码实现**\n\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int n=0;int m=0;    //用来存放输入的n和m\n    vector<int> list;   //存放输入的喜爱值\n\n    //读入数据\n    scanf(\"%d %d\",&n,&m);\n    getchar();  //去除回车 以防万一\n    int itemp=0;    //暂存读入的数据，用来加入vector\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        list.push_back(itemp);\n    }\n\n    int Max=0;  //保存最终的结果\n    int left=0;int right=0; //保存最大值的左右区间\n    int left_t=0;int right_t=0;\n    int max_t=0;    //用来保存每个子序列的最大值\n    int sum=0;  //用来保存每个子序列的和;\n    //遍历数据\n    for (int i = 0; i < n; ++i)\n    {\n        max_t=0;\n        sum=0;\n        int j=i;\n        for(j=i;j<i+m&&j<n;++j){\n            sum+=list[j];\n            if(sum>max_t){\n                max_t=sum;\n                left_t=i;\n                right_t=j;\n            }\n        }\n        if(max_t>Max){\n            Max=max_t;\n            left=left_t;\n            right=right_t;\n        }\n    }\n    printf(\"%d %d %d\",Max,left+1,right+1);\n    return 0;\n}\n```\n\n**分析:**\n使用暴力法的时间复杂度显然是O(n*m)的，这实在太慢了:sweat_smile:，~~*虽然还有更慢的*~~ 很容易被时间限制卡住。\n\n#### 方法二:单调队列\n\n要使用单调队列，我们需要引入一个前缀和序列。\n维护这样一个前缀和的单调队列，区间范围为m，则队列首元素为该区间中的最小值，用区间内的前缀和去减去这个最小值，则得到值最大的，为该序列中子序列的最大值\n**举个栗子**\n\n```plain\n对于数据\n5 2\n1 4 5 -1 3\n有前缀序列\n0,1,5,10,9,12\n维护一个单调非递减的单调序列\n1 [0],1,5,10,9,12   max=0;max!<0;max=0;\n2 [0,1],5,10,9,12   max=0;max<1-0;max=1;\n3 [0,1,5],10,9,12   max=1;max<5-0;max=5;\n以上行为每次进行一次队尾减去队首的值与max进行比较的操作。\n最开始的时候因为不满一个区间的长度(m+1,多了初始点0)所以不做操作\n4.1 [0,1,5,]10,9,12  此时超过区间的长度，即将要加入5，而5满足非递减的要求可以入队，否则弹出队尾元素直至可入队\n4.2 [0,1,5,10],9,12  此时维护区间 发现0已经在区间外了，*ps：现在指针指向的数为前缀和序列中的10* 将队首元素弹出队列\n4.3 0,[1,5,10],9,12  max=5;max<10-1;max=9;\n5.1 0,[1,5,10,]9,12  9显然不满足要求\n5.2 0,[1,5]10,[9],9,12  维护区间\n5.3 0,1,[5]10,[9],12 max=9;max!<9-5;max=9;\n......\n直至运行结束\n```\n\n&#160;**代码实现**\n\n```c++\n#include<iostream>\n#include<vector>\n#include<deque>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int n=0;int m=0;    //用来存放输入的n和m\n    vector<int> preSum; //保存前缀和    并不需要保存喜欢值序列\n    deque<pair<int,int>> MQueue;    //单调队列  first 存储数据 second 存储下标\n    int Max=0;\n    int left=0;int right=0;\n\n    //读入数据\n    scanf(\"%d %d\",&n,&m);\n    getchar();  //去除回车 以防万一\n    int itemp=0;    //暂存读入的数据，用来加入vector\n    preSum.push_back(0);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&itemp);\n        getchar();\n        preSum.push_back(preSum[i-1]+itemp);\n    }\n    for(int i=0;i<=n;++i){\n        //入队并维持单调性\n        if(MQueue.empty()||preSum[i]>=MQueue.back().first){\n            MQueue.push_back(pair<int,int>(preSum[i],i));\n        }else{\n            while (!MQueue.empty()&&MQueue.back().first>preSum[i])\n            {\n                MQueue.pop_back();\n            }\n            MQueue.push_back(pair<int,int>(preSum[i],i));\n        }\n        //维护区间\n        if(i>=m){\n            while (!MQueue.empty()&&MQueue.front().second<i-m)\n            {\n                MQueue.pop_front();\n            }\n        }\n\n        //与max进行比较\n        if(Max<MQueue.back().first-MQueue.front().first){\n            Max=MQueue.back().first-MQueue.front().first;\n            left=MQueue.front().second;\n            right=MQueue.back().second;\n        }\n\n    }\n    printf(\"%d %d %d\",Max,left+1,right);\n    return 0;\n}\n```\n\n**分析**\n因为每个前缀和序列中的元素只被访问了一次，时间复杂度是O(n),可以看到相比暴力穷举法，时间效率大大的提高了。如果使用数组自己维护双端队列 则空间还可以节省三分之一 ~~*我是five懒得写了*~~\n\n---\n<div align=\"center\">\n<font style=\"font-weight:bold\" size='4'>下列方法只适用于不限制子序列长度</font>\n</div>\n\n#### 方法三:分治法\n\n总的来说就是分三种情况来分治\n\n1. 找到左半部分的最大子序列的和\n\n2. 找到右半部分的最大子序列的和\n\n3. 找到中间跨边界的最大子序列的和\n\n    1. 向左一步，计算和，若大于上一步的和则更新\n\n    2. 向右一步，计算和，若大于上一步的和则更新\n\n    3. 将左侧的和与右侧的和相加得到中间的和\n\n&#160;**代码实现**\n~~*真的写不出能分治出定长区间和区间端点的*~~:cry:\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n = 0;\nint m = 0;        //用来存放输入的n和m\nvector<int> list; //存放输入的喜爱值\n\nint toSolve(int left, int right)\n{\n    if (left == right)\n    {\n        return list[left];\n    }\n    int middle = (left + right) >> 1;\n    int sum_left = toSolve(left, middle);\n    int sum_right = toSolve(middle + 1, right);\n    int sumL = 0, sumR = 0, tL = 0, tR = 0;\n    for (int i = middle; i >= left; --i)\n    {\n        tL += list[i];\n        sumL = max(sumL, tL);\n    }\n    for (int i = middle + 1; i < right; ++i)\n    {\n        tR += list[i];\n        sumR = max(sumR, tR);\n    }\n    int sum = sumL + sumR;\n\n    return max(max(sum_left, sum_right), sum);\n}\n\nint main(int argc, char const *argv[])\n{\n    //读入数据\n    scanf(\"%d %d\", &n, &m);\n    getchar();     //去除回车 以防万一\n    int itemp = 0; //暂存读入的数据，用来加入vector\n    for (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", &itemp);\n        getchar();\n        list.push_back(itemp);\n    }\n    int Max = toSolve(0, n - 1);\n\n    printf(\"%d\", Max);\n    return 0;\n}\n```\n\n**算法分析**\n最坏时间复杂度为O($n^2$)阶的，因为最终每个递归树叶子节点都遍历了全部链表~~并没有比优化后的暴力好~~\n最优时间复杂度为O(n),每个叶子节点都只遍历了一遍\n期望时间复杂度应该是O($n\\log n$)\n\n#### 方法四:动态规划\n\n用动态规划的思路去思考问题，每一步决策无非就是，是否将下一个数加入到当前的序列中\n因为我们只求和，所以只需要用一个变量来存放当前序列的和\n为什么可以这样做？\n因为和最大的连续子序列拥有最优子结构的特性\n例如在[-1,4,5,-10,3]中\n[4,5]是和最大的连续子序列\n而[4]也是在[-1,4]中和最大的连续子序列。\n**代码实现**\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n = 0;\nint m = 0;        //用来存放输入的n和m\nvector<int> list; //存放输入的喜爱值\nint main(int argc, char const *argv[])\n{\n    //读入数据\n    scanf(\"%d %d\", &n, &m);\n    getchar();     //去除回车 以防万一\n    int itemp = 0; //暂存读入的数据，用来加入vector\n    for (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", &itemp);\n        getchar();\n        list.push_back(itemp);\n    }\n    int Max=0;\n    int Max_t=0;\n    Max_t=list[0];\n    for(int i=1;i<n;++i){\n        if(Max_t){\n            Max_t=Max_t+list[i];\n        }else{\n            Max_t=list[i];  //这里假设了有从i开始的和最大的子序列\n        }\n        Max=max(Max,Max_t);//可以修改此段以输出最大子序列的和的区间端点\n    }\n    printf(\"%d\", Max);\n    return 0;\n}\n```\n\n&#160;**算法分析**\n很显然，整个算法只扫描了一遍序列，算法的时间复杂度是O(n)的，与单调队列一样。这个算法还有个名字叫[kadane算法](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98/22828059#1)。用动态规划还是非常不错的，代码短速度快空间也省。~~*就是不能很好的契合这道题*~~:sweat_smile:\n\n## 总结\n\n总得来说求最大连续子序列和的问题有这样四种思路，各有优缺点，其中暴力法容易理解；单调队列适用场景广；分治法虽然在这里可行，但显然难以发挥其优势；而动态规划可以说没有缺点 ~~(我是five，不知道能不能改成定长区间的)~~。所以在合适的场景选择合适的算法才是\\*ao\\*的。极力推荐，单调队列和动态规划。\n","tags":["数据结构与算法","应用"],"categories":["数据结构与算法","应用","最大连续子序列的和"]},{"title":"个人博客搭建历程","url":"/posts/bf7e5576/","content":"\n---\n\n## 萌芽\n\n第一次想到要搭建一个个人主页是在7年前，当时看到有个B站的up主整了个个人主页来发布资源，我就想着我也想并应该能整一个。于是乎一场历时将近7年的技术积累开始了。\n<!--more-->\n\n## 准备\n\n### 设备\n\n作为一个学生党，起初我天真的以为，网页必须部署在一台自己拥有的服务器或者云服务器上，而贫穷的初中生并没有钱，于是乎想到用家里废弃的笔记本来充当服务器。但是这就遇到了一个麻烦，笔记本上原先装的为winXP系统，而为了节省资源，应该使用Linux服务器系统。所以，我第一个倒腾的玩意，就是如何给电脑重装系统，并且是装不同的系统。  \n\n当时的我还是初一学生，理解能力并不强，看了网上好几篇装系统的教程，硬是没搞到所谓的BIOS，PE是什么玩意，我当时就想，为什么装个系统要用另一个软件，系统自己难道不提供安装方法的吗？带着这样的疑问，我继续找资料，过了一个月，看了文章，视频，渐渐的我开始认识到BIOS是什么东西，也知道了装系统除了用PE还可以将系统镜像录入U盘来安装。  \n\n虽然知道了这些知识，但是都是基于安装windows系统的，关于Linux系统的安装我毫无概念，不要说如何将Linux的文件烧录到U盘了，我连当时Linux到底是个什么玩意都没整清楚，一会是Ubuntu一会是CentOS，直到后来才有了Linux发行版的概念。于是带着试试的心态我按着网上的教程去下Ubuntu来安装，经过迅雷漫长的下载，得到的iso文件我没一点想法，我知道是虚拟光驱文件，但是如何给它做成安装盘，还是得不断的找资料和试错。  \n\n最终，我找到了一个ISO烧录到U盘的万能工具Rufus，~~真的非常好用强烈推荐~~，用它我成功制作出了第一块能用的安装盘。然后，经过一番周折，在老旧的笔记本上装上了Ubuntu16.04桌面版。至此，我成功积累了设备上的技术。  \n\n### 网络\n\n网络层面的技术积累，得从游戏Minecraft(我的世界)谈起，当时我沉迷我的世界游戏，但是单人实在无聊，想着跟好友联机。但是中国互联网的环境我们都知道————一个大内网，实现联机可谓是如登蜀道，翻遍网上的各种教程，有教蛤蟆吃~~（hamachi）~~的、有教花生壳的......可谓是五花八门，除了用花生壳，总之其他软件我就没成功过，可是花生壳的效果也十分不理想。有人可能会说用樱花映射（Sakura frp），6年前还没有这些东西呢~~虽然好像听说有企划~~。  \n\n为了获得良好的游戏体验，我几乎翻遍了MCBBS中的联机教程，最终找到一篇内外网开服教程。教程讲述了如何进入电信的光猫去设置端口映射。于是我算是找到了突破口——进入光猫超级管理页面。\n光猫是华为的而且根据型号去找超级密码的获取教程没一个对应的，所提供的工具都无法打开telnet端口，这就很让我绝望。但是我不甘放弃，经历2个星期的寻找，最终找到了什么组播工具，成功的打开了光猫的telnet端口，从中下载到了配置文件，经过解码最终得到了超级管理员的密码，成功建立了映射。\n\n在这之后，我又整上了DDNS。至此，成功将家里的内网与外网打通了，愉快的开起了Minecraft服务器，和基友快乐联机。\n\n### Nginx\n\n装上了Ubuntu server,有了外网环境，我开始研究如何建立一个web站点，经过多方查找，结合手上机器的性能，我觉得应该使用一个叫Nginx的玩意，~~(别和我说宝塔面板和Apache，当时我根本没找到一点教程，还是初中生，认知能力较浅)~~ 于是乎我又去看了Nginx的教程，发现是真的博大精深，不是当时我所能看懂的，但是我所求的也不是什么高级功能，我决定照样画葫芦试试,照着教程开始配置nginx.conf，一通照搬猛如虎啊，感觉自己可行了。改完一跑啊，原本的welcome都没了，404也见不到了。就这样折腾了一个月，模模糊糊的对nginx理解了大概有了一定的对象思想，然后因为学业压力，暂时搁置了。\n\n直到最近，大学的我重新拾起了建个人博客的兴趣，看到了一篇[教程](https://zhuanlan.zhihu.com/p/58654392)，加上多年来的沉淀，我终于明白了正确使用Nginx的方式:cry:conf文件几乎完全不用动……\n\n## 行动\n\n### Hexo\n\n使用Hexo其实是一种偷懒，本来最初我是想自己学习web开发来自己写一个个人主页的，但是后来当我向我学前端的姐姐提出了要搭建个人博客的想法，并试图白嫖引擎时，她向我指出了[Hexo](https://hexo.io/zh-cn/index.html)。在看了相关教程和Hexo的文档后，觉得确实容易上手，这里要特别感谢此博客所用主题[Stun](https://theme-stun.github.io/docs/zh-CN/)提供了不仅主题，而且还有Hexo原版的配置教程，甚至还有第三方已经辅助优化的教程，这种堪称小白级的教程，真的让我省了不少功夫。\n\n在稍微学了下npm的相关知识后，当我将`npx hexo d`按下之后，博客的雏形就形成了，让我切实的体会到了有成果的成就感，那是一种难以言表的快乐，比打游戏还来得让人舒爽与充实，这么多的时间并没有白费。\n\n*你可以通过[此处](https://yurzi.github.io)来访问我部署在GitHub上的同样内容*\n\n### 域名与Https\n\n域名还是比较容易获得的东西，就是要吃几日土，为了梦想还是值得的。\n\n除去域名，为什么要折腾https呢？因为我想将站点部署到自己的服务器上，这样可以不必要使用在线图床，而使用服务器上的图片，~~*就是闲着慌*~~。\n\nhttps的关键就是申请证书，基于我在自己搭建科学上网工具上的经验，我立刻想起了Let's Encrypt，顺着这个线索也就自然的找到了[acme.sh](https://github.com/acmesh-official/acme.sh)。acme的使用的教程还是比较多的，以及其提供的文档也很丰富，我照猫画虎也很快上手并申请到了证书。\n\n申请到证书之后就是讲证书部署到nginx上，一开始我是照着网上一个看着很简单的教程来做的，但是效果并不是很好 ~~*（完全不能用）*~~:sweat_smile:，最终acme的文档给出了一个优质[教程](https://www.cyberciti.biz/faq/how-to-configure-nginx-with-free-lets-encrypt-ssl-certificate-on-debian-or-ubuntu-linux/)，结合着这篇文章，最终配置成功了。\n\n~~*最后说是成功其实并没有成功，因为国内域名备案后才能解析到国内的服务器空间，而且运营商还限制相关端口，备案对于我难度过大，而通过国外服务器空间来搭建反向代理还不如将站点整个部署到国外的服务器上，于是乎就这样了*~~\n\n## 总结\n\n经过这长达6年断断续续的准备和研究，最终梦想得以实现，令我内心感到由衷的喜悦和充实，再一次让我更加肯定自身的个人价值，提升了我的自信；同时，在这个过程中，我也学习并掌握了很多技术，虽然可能只是一点皮毛，但也确实拓宽了视野，提升了能力。\n\n最后我要由衷的感谢撰写教程和文档的朋友，你们的分享精神，让许多像我这样的人得以收益，得以去实现自己的梦想。你们的分享精神，使得互联网里照进了一丝丝阳光。而现在开始，我也将投身于这个行列，为他人做出自己的贡献\n\n（End）\n","tags":["Linux"],"categories":["经历"]},{"title":"洛玖只的学生日常-第一章","url":"/posts/b78dffe7/","content":"\n---\n\n## 九阳豆浆机\n\n相传在上古时期，后羿射日之时，天上的九个太阳落下后，汇聚起来化作了一台豆浆机，拥有可怕的威能。  \n这台豆浆机，自出现后，便再无音讯，遗失在苍茫的宇宙中，难以寻觅，是为传说中的上古先天神器。  \n\n而现在，在这教室里，九阳豆浆机就在考列考拉夫斯基的手上，并向我们炫耀其造型之精美。我们虽然对此感到怀疑，但是其造型确实精美好看，  \n寒冬的阳光，透过朦胧的紧闭的玻璃窗，在了豆浆机上，让洁白的陶瓷质的光滑外壳，亮的有些闪眼；  \n镀银的提手，低调奢华有内涵；盖子银质镶圈，带有一个用金丝勾勒出的九阳界面，  \n在封闭的教室中，在水汽的氤氲下，显得十分的富丽堂皇，并有一种仙气，超然脱俗。  \n<!--more-->\n\n“你这豆浆机的确像那么回事，不过现在都0202年了，哪里来的上古神器，别瞎扯了”，查拉图斯特拉杰，笑着嘲讽考列考拉夫斯基，  \n“而且你这玩意插头都没有，怎么用啊？”  \n\n考列考拉夫斯基十分不屑的瞥了查拉图斯特拉杰一眼，从课桌抽屉里舀出一杯黄豆倒入“九阳豆浆机”，又加入一杯直饮开水机接的开水，合上盖子。  \n这时煤球与上杉漠槿接完水，从教室外面逛完回来，看到考列考拉夫斯基的架势有些惊异。  \n“你是要帮我磨豆浆吗，考拉？”煤球的表情有些诡异，语调也变得奇怪了起来。  \n“哦↗~“，上杉漠槿恍然大悟似的赞叹道，“磨豆浆啊，太刺激了！没想到啊，考拉！”  \n刹那间，还对煤球话语感到奇怪的在座的我们都笑了，周围都弥漫着快活的空气。  \n\n“ん？”，考列考拉夫斯基一脸惊异，眼睛微微瞪大，但手上动作不停，用不知道什么方法启动了豆浆机。  \n只听见一阵剧烈的摩擦声，是黄豆与刀片的水乳交融，不出5秒，便有一股香醇的豆浆的香味飘溢而出，撩拨着人的嗅觉神经，  \n之前面带嬉笑的众人，纷纷咽起了口水，在轰鸣声中，不出一分钟，伴随着滴的一声，豆浆磨好了，  \n众人自觉的拿出自己的杯子，眼巴巴的等待着考列考拉夫斯基分配豆浆。  \n\n豆浆入口，温热而微甜，伴随着黄豆原本的清香，浸透了咽喉与鼻腔，虽然未过筛，但黄豆渣已经细如齑粉，与豆浆混合在一起，增加了豆浆的软糯。  \n轻嘬一口，豆浆自口舌间滑落咽喉，整个食道，被如暖阳般的流体熨帖的一阵痉挛。此事，豆浆机上的金丝九阳仿佛显的格外的耀眼。  \n\n“真不愧是考拉为我磨的豆浆啊，真的是好喝。”煤球赞叹道。  \n考列考拉夫斯基显得有些得意，对着查拉图斯特拉杰勾了勾下巴，“现在你相信了吧，杰？”  \n“我敢保证这绝对是真的豆浆机，考列考拉夫斯基是真的强啊！”查拉图斯特拉杰已经被九阳豆浆机所折服，刚喝完豆浆的他，面色红润，显得皮肤好像又黝黑了一分。  \n喝完豆浆，众人都瘫坐在座位上，考列考拉夫斯基摸着自己浑圆的肚子，眼神微眯，看着豆浆机：“九阳豆浆机是靠仙力来运转的，听说往其中注入大量仙力，  \n便可以化作十阳豆浆机，那样磨出的豆浆据说更香。”  \n\n“那十阳豆浆机，继续注入仙力，是不是可以归十为一化作元阳豆浆机，虚空产豆浆？”洛玖只打了个饱嗝，好奇的问道。  \n“也许吧，那样就有无限的豆浆喝了。”考列考拉夫斯基感慨道。  \n“那不是再也不用去买食堂2块钱这么一小杯又难喝掺水的豆浆了？“煤球有些兴奋的说道，查拉图斯特拉杰也两眼放光。  \n“那就试试吧！”洛玖只伸出手放在豆浆机上，只见豆浆机上的九阳发出九道刺眼的光芒，随着仙力的不断涌入，突然间九道金光中又出现了一道金光，十阳交相辉映，  \n格外的明亮，强烈的太阳辐射让众人用手遮挡，同时也照得查拉图斯特拉杰更加的黝黑。  \n“金色传说！”此时风月冷萤正从一边经过。同时刚转完水的马艺和星天归尘从边上默默的走过，瞟了那光一眼，有点惊异但也就有点惊异。  \n“还没完呢“，洛玖只没有移开手，十阳的强度进一步增强，一抹紫光渐渐的从金光中投射出来，逐渐吞噬蚕食了其他的金光。最终只留下一轮紫金的元阳烙印在豆浆机上。  \n“真的是强啦，玖只！”考列考拉夫斯基放下挡光的手，阴阳怪气的说道。  \n洛玖只收回手有些得意，早就充满的馋意急切的催促考列考拉夫斯基：“我们快试试吧。”  \n\n考列考拉夫斯基伸出手抚在豆浆机上，缓缓运功催动豆浆机。豆浆机的那轮紫阳微微闪烁，渐渐的便有一股豆浆的醇香逸散开来。  \n“这好像可以出其他豆的豆浆诶！”考列考拉夫斯基有些惊讶，从豆浆机中倒出一杯绿豆浆来，微嘬一口，  \n绿豆浆独有的清香便俘获了他的味蕾，“这还不错，风味独特，杰你要不要来点？”  \n\n查拉图斯特拉杰的表情有点怪异，眉毛上扬，眼神中充满了不可思议：“真就虚空产豆浆呗，质能守恒就这么没面子吗？”  \n“都什么时候了，还质能守恒啊？炼金术听说过没？”上杉漠槿不耐烦的吐槽，“别磨蹭了，考拉，快给我来一杯。”  \n说着将考列考拉夫斯基的一升行军保温壶从桌下掏了出来，立在桌子上。  \n\n“欸，你这就有点过分了啊！”考列考拉夫斯基急忙掠过自己的水壶，笑着开始往里面灌豆浆，倒了满满一壶后，  \n往众人面前的杯子中倒上了各自的喜爱的口味，并贴心的给风月冷萤也倒上了一杯。  \n\n“黑豆浆是真的好喝啦，考拉~”煤球抿了大一口赞叹道。  \n“就是不甜。”风月冷萤淡淡的评价道。  \n“对啊，就是不甜，要是能变甜就好了，只可惜这个豆浆机只能凭空产生豆浆，不能虚空产糖。”洛玖只喝了一大口，咂咂嘴惋惜的感叹。  \n考列考拉夫斯基听到这分析道：“那没事，豆浆的主要成分是豆蛋白，由 C H O N等元素组成，只要用操纵豆浆机让它把豆浆拆解成基本元素，再重组出$C_6H_{12}O_6$果糖就行了。”  \n\n“不愧是考拉，真的是强啦~”，煤球笑着称赞考列考拉夫斯基，“这你都想的出来，不愧是你澳大利亚2000万只考拉信仰的神。”  \n“你这个是真的太化学了耶~，这样怕是可以虚空产生钻石了。”查拉图斯特拉杰感叹道，面容沮丧，仿佛自己的信仰被完全摧毁似的。  \n“你们别在这磨叽了，先赶快把糖搞出来吧，还在这里扯来扯去。”上杉漠槿不耐烦的催促。  \n\n于是乎，在众目睽睽之下，考列考拉夫斯基伸出手放在了“九阳”豆浆机上，微闭双目，全神贯注，似乎是在尽力操纵豆浆机。  \n豆浆机上的紫阳微微开始闪烁，时间一分一秒的过去了，“行不行啦，考拉？”上杉漠槿看着考列考拉夫斯基头上逐渐冒出的汗滴询问。  \n考列考拉夫斯基不说话。终于紫阳开始疯狂闪烁，洛玖只赶紧捏了个结界，众人摒住了呼吸，怕发生什么意外。  \n\n","tags":["小说","洛玖只的学生日常"],"categories":["小说","洛玖只的日常","第一章"]},{"title":"洛玖只的学生日常-前言","url":"/posts/c96fa57/","content":"\n---\n\n## 写在前面\n\n本文为奇幻题材小说，依据洛玖只(本人)高中生活日常趣闻及幻想改编  \n具有无厘头等要素，文笔不佳，轻喷，请轻松观看！  \n\n## 序章\n\n2019年，这年我，洛玖只好不容易熬到了高三，怕生的玖只，终于和其小伙伴逐渐熟络，并结下了难以解除的羁绊。  \n高三紧张的复习，时常压得玖只和小伙伴们透不过气来，在经过半年的折磨后，他们一个个终于难以忍受，做出了一个决定。\n于是乎在2020年，高三的生活，开始逐渐变得奇妙了起来......  \n\n参演人员：洛玖只 考列考拉夫斯基 煤球 马艺 查拉图斯特拉杰 上杉漠槿 星天归尘 风月冷萤  \n","tags":["小说","洛玖只的学生日常"],"categories":["小说","洛玖只的日常","前言"]}]